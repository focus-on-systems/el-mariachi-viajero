# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Node {
    "The id of the object."
    id: ID!
}

"The ParseObject interface type is used as a base type for the auto generated object types."
interface ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "This is the object id."
    objectId: ID!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"The SchemaField interface type is used as a base type for the different supported fields of an object class schema."
interface SchemaField {
    "This is the field name."
    name: String!
}

"Use Inline Fragment on Array to get results: https://graphql.org/learn/queries/#inline-fragments"
union ArrayResult = B4aCustomField | B4aMenuItem | B4aSetting | Category | Element | MyClass | Pack | PackPromotion | Place | Promotion | Role | Session | State | Tour | TourCategory | TourImage | TourPlace | TourPromotion | ToursInPack | User

"Current access control list of the current object."
type ACL {
    "Public access control list."
    public: PublicACL
    "Access control list for roles."
    roles: [RoleACL!]
    "Access control list for users."
    users: [UserACL!]
}

"The B4aCustomField object type is used in operations that involve outputting objects of B4aCustomField class."
type B4aCustomField implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "This is the object cssClassName."
    cssClassName: String
    "This is the object defaultValue."
    defaultValue: String
    "The ID of an object"
    id: ID!
    "This is the object inputMask."
    inputMask: String
    "This is the object isFormHidden."
    isFormHidden: String
    "This is the object isRequired."
    isRequired: Boolean
    "This is the object isTableHidden."
    isTableHidden: Boolean
    "This is the object objectClassFieldName."
    objectClassFieldName: String
    "This is the object objectClassName."
    objectClassName: String
    "This is the object id."
    objectId: ID!
    "This is the object options."
    options: String
    "This is the object referenceTitleField."
    referenceTitleField: String
    "This is the object referencesLinkText."
    referencesLinkText: String
    "This is the object referencesLinkTitle."
    referencesLinkTitle: String
    "This is the object relevance."
    relevance: Float
    "This is the object subType."
    subType: String
    "This is the object title."
    title: String
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type B4aCustomFieldConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [B4aCustomFieldEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type B4aCustomFieldEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: B4aCustomField
}

"The B4aMenuItem object type is used in operations that involve outputting objects of B4aMenuItem class."
type B4aMenuItem implements Node & ParseObject {
    ACL: ACL!
    "This is the object addFormTitle."
    addFormTitle: String
    "This is the date in which the object was created."
    createdAt: Date!
    "This is the object editFormTitle."
    editFormTitle: String
    "The ID of an object"
    id: ID!
    "This is the object isHidden."
    isHidden: Boolean
    "This is the object isReadOnly."
    isReadOnly: Boolean
    "This is the object objectClassName."
    objectClassName: String
    "This is the object id."
    objectId: ID!
    "This is the object relevance."
    relevance: String
    "This is the object title."
    title: String
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type B4aMenuItemConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [B4aMenuItemEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type B4aMenuItemEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: B4aMenuItem
}

"The B4aSetting object type is used in operations that involve outputting objects of B4aSetting class."
type B4aSetting implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object key."
    key: String
    "This is the object id."
    objectId: ID!
    "This is the date in which the object was las updated."
    updatedAt: Date!
    "This is the object value."
    value: String
}

"A connection to a list of items."
type B4aSettingConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [B4aSettingEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type B4aSettingEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: B4aSetting
}

"The Category object type is used in operations that involve outputting objects of Category class."
type Category implements Node & ParseObject {
    ACL: ACL!
    "This is the object categoryIcon."
    categoryIcon: String!
    "This is the object categoryIconType."
    categoryIconType: Float!
    "This is the object categoryImg."
    categoryImg: FileInfo!
    "This is the object categoryName."
    categoryName: String!
    "This is the object categoryThumb."
    categoryThumb: FileInfo!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type CategoryConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [CategoryEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type CategoryEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Category
}

"The Class type is used to return the information about an object class."
type Class {
    "This is the name of the object class."
    name: String!
    "These are the schema's fields of the object class."
    schemaFields: [SchemaField!]!
}

type CreateB4aCustomFieldPayload {
    "This is the created object."
    b4aCustomField: B4aCustomField!
    clientMutationId: String
}

type CreateB4aMenuItemPayload {
    "This is the created object."
    b4aMenuItem: B4aMenuItem!
    clientMutationId: String
}

type CreateB4aSettingPayload {
    "This is the created object."
    b4aSetting: B4aSetting!
    clientMutationId: String
}

type CreateCategoryPayload {
    "This is the created object."
    category: Category!
    clientMutationId: String
}

type CreateClassPayload {
    "This is the created class."
    class: Class!
    clientMutationId: String
}

type CreateFilePayload {
    clientMutationId: String
    "This is the created file info."
    fileInfo: FileInfo!
}

type CreateMyClassPayload {
    clientMutationId: String
    "This is the created object."
    myClass: MyClass!
}

type CreatePackPayload {
    clientMutationId: String
    "This is the created object."
    pack: Pack!
}

type CreatePackPromotionPayload {
    clientMutationId: String
    "This is the created object."
    packPromotion: PackPromotion!
}

type CreatePlacePayload {
    clientMutationId: String
    "This is the created object."
    place: Place!
}

type CreatePromotionPayload {
    clientMutationId: String
    "This is the created object."
    promotion: Promotion!
}

type CreateRolePayload {
    clientMutationId: String
    "This is the created object."
    role: Role!
}

type CreateSessionPayload {
    clientMutationId: String
    "This is the created object."
    session: Session!
}

type CreateStatePayload {
    clientMutationId: String
    "This is the created object."
    state: State!
}

type CreateTourCategoryPayload {
    clientMutationId: String
    "This is the created object."
    tourCategory: TourCategory!
}

type CreateTourImagePayload {
    clientMutationId: String
    "This is the created object."
    tourImage: TourImage!
}

type CreateTourPayload {
    clientMutationId: String
    "This is the created object."
    tour: Tour!
}

type CreateTourPlacePayload {
    clientMutationId: String
    "This is the created object."
    tourPlace: TourPlace!
}

type CreateTourPromotionPayload {
    clientMutationId: String
    "This is the created object."
    tourPromotion: TourPromotion!
}

type CreateToursInPackPayload {
    clientMutationId: String
    "This is the created object."
    toursInPack: ToursInPack!
}

type CreateUserPayload {
    clientMutationId: String
    "This is the created object."
    user: User!
}

type DeleteB4aCustomFieldPayload {
    "This is the deleted object."
    b4aCustomField: B4aCustomField!
    clientMutationId: String
}

type DeleteB4aMenuItemPayload {
    "This is the deleted object."
    b4aMenuItem: B4aMenuItem!
    clientMutationId: String
}

type DeleteB4aSettingPayload {
    "This is the deleted object."
    b4aSetting: B4aSetting!
    clientMutationId: String
}

type DeleteCategoryPayload {
    "This is the deleted object."
    category: Category!
    clientMutationId: String
}

type DeleteClassPayload {
    "This is the deleted class."
    class: Class!
    clientMutationId: String
}

type DeleteMyClassPayload {
    clientMutationId: String
    "This is the deleted object."
    myClass: MyClass!
}

type DeletePackPayload {
    clientMutationId: String
    "This is the deleted object."
    pack: Pack!
}

type DeletePackPromotionPayload {
    clientMutationId: String
    "This is the deleted object."
    packPromotion: PackPromotion!
}

type DeletePlacePayload {
    clientMutationId: String
    "This is the deleted object."
    place: Place!
}

type DeletePromotionPayload {
    clientMutationId: String
    "This is the deleted object."
    promotion: Promotion!
}

type DeleteRolePayload {
    clientMutationId: String
    "This is the deleted object."
    role: Role!
}

type DeleteSessionPayload {
    clientMutationId: String
    "This is the deleted object."
    session: Session!
}

type DeleteStatePayload {
    clientMutationId: String
    "This is the deleted object."
    state: State!
}

type DeleteTourCategoryPayload {
    clientMutationId: String
    "This is the deleted object."
    tourCategory: TourCategory!
}

type DeleteTourImagePayload {
    clientMutationId: String
    "This is the deleted object."
    tourImage: TourImage!
}

type DeleteTourPayload {
    clientMutationId: String
    "This is the deleted object."
    tour: Tour!
}

type DeleteTourPlacePayload {
    clientMutationId: String
    "This is the deleted object."
    tourPlace: TourPlace!
}

type DeleteTourPromotionPayload {
    clientMutationId: String
    "This is the deleted object."
    tourPromotion: TourPromotion!
}

type DeleteToursInPackPayload {
    clientMutationId: String
    "This is the deleted object."
    toursInPack: ToursInPack!
}

type DeleteUserPayload {
    clientMutationId: String
    "This is the deleted object."
    user: User!
}

"The Element object type is used to return array items' value."
type Element {
    "Return the value of the element in the array"
    value: Any!
}

"The FileInfo object type is used to return the information about files."
type FileInfo {
    "This is the file name."
    name: String!
    "This is the url in which the file can be downloaded."
    url: String!
}

"The GeoPoint object type is used to return the information about geo point fields."
type GeoPoint {
    "This is the latitude."
    latitude: Float!
    "This is the longitude."
    longitude: Float!
}

type LogInPayload {
    clientMutationId: String
    "This is the existing user that was logged in and returned as a viewer."
    viewer: Viewer!
}

type LogInWithPayload {
    clientMutationId: String
    "This is the new user that was created, signed up and returned as a viewer."
    viewer: Viewer!
}

type LogOutPayload {
    clientMutationId: String
    "It's always true."
    ok: Boolean!
}

"Mutation is the top level type for mutations."
type Mutation {
    "The createB4aCustomField mutation can be used to create a new object of the B4aCustomField class."
    createB4aCustomField(input: CreateB4aCustomFieldInput!): CreateB4aCustomFieldPayload
    "The createB4aMenuItem mutation can be used to create a new object of the B4aMenuItem class."
    createB4aMenuItem(input: CreateB4aMenuItemInput!): CreateB4aMenuItemPayload
    "The createB4aSetting mutation can be used to create a new object of the B4aSetting class."
    createB4aSetting(input: CreateB4aSettingInput!): CreateB4aSettingPayload
    "The createCategory mutation can be used to create a new object of the Category class."
    createCategory(input: CreateCategoryInput!): CreateCategoryPayload
    "The createClass mutation can be used to create the schema for a new object class."
    createClass(input: CreateClassInput!): CreateClassPayload
    "The createFile mutation can be used to create and upload a new file."
    createFile(input: CreateFileInput!): CreateFilePayload
    "The createMyClass mutation can be used to create a new object of the MyClass class."
    createMyClass(input: CreateMyClassInput!): CreateMyClassPayload
    "The createPack mutation can be used to create a new object of the Pack class."
    createPack(input: CreatePackInput!): CreatePackPayload
    "The createPackPromotion mutation can be used to create a new object of the PackPromotion class."
    createPackPromotion(input: CreatePackPromotionInput!): CreatePackPromotionPayload
    "The createPlace mutation can be used to create a new object of the Place class."
    createPlace(input: CreatePlaceInput!): CreatePlacePayload
    "The createPromotion mutation can be used to create a new object of the Promotion class."
    createPromotion(input: CreatePromotionInput!): CreatePromotionPayload
    "The createRole mutation can be used to create a new object of the Role class."
    createRole(input: CreateRoleInput!): CreateRolePayload
    "The createSession mutation can be used to create a new object of the Session class."
    createSession(input: CreateSessionInput!): CreateSessionPayload
    "The createState mutation can be used to create a new object of the State class."
    createState(input: CreateStateInput!): CreateStatePayload
    "The createTour mutation can be used to create a new object of the Tour class."
    createTour(input: CreateTourInput!): CreateTourPayload
    "The createTourCategory mutation can be used to create a new object of the TourCategory class."
    createTourCategory(input: CreateTourCategoryInput!): CreateTourCategoryPayload
    "The createTourImage mutation can be used to create a new object of the TourImage class."
    createTourImage(input: CreateTourImageInput!): CreateTourImagePayload
    "The createTourPlace mutation can be used to create a new object of the TourPlace class."
    createTourPlace(input: CreateTourPlaceInput!): CreateTourPlacePayload
    "The createTourPromotion mutation can be used to create a new object of the TourPromotion class."
    createTourPromotion(input: CreateTourPromotionInput!): CreateTourPromotionPayload
    "The createToursInPack mutation can be used to create a new object of the ToursInPack class."
    createToursInPack(input: CreateToursInPackInput!): CreateToursInPackPayload
    "The createUser mutation can be used to create a new object of the User class."
    createUser(input: CreateUserInput!): CreateUserPayload
    "The deleteB4aCustomField mutation can be used to delete an object of the B4aCustomField class."
    deleteB4aCustomField(input: DeleteB4aCustomFieldInput!): DeleteB4aCustomFieldPayload
    "The deleteB4aMenuItem mutation can be used to delete an object of the B4aMenuItem class."
    deleteB4aMenuItem(input: DeleteB4aMenuItemInput!): DeleteB4aMenuItemPayload
    "The deleteB4aSetting mutation can be used to delete an object of the B4aSetting class."
    deleteB4aSetting(input: DeleteB4aSettingInput!): DeleteB4aSettingPayload
    "The deleteCategory mutation can be used to delete an object of the Category class."
    deleteCategory(input: DeleteCategoryInput!): DeleteCategoryPayload
    "The deleteClass mutation can be used to delete an existing object class."
    deleteClass(input: DeleteClassInput!): DeleteClassPayload
    "The deleteMyClass mutation can be used to delete an object of the MyClass class."
    deleteMyClass(input: DeleteMyClassInput!): DeleteMyClassPayload
    "The deletePack mutation can be used to delete an object of the Pack class."
    deletePack(input: DeletePackInput!): DeletePackPayload
    "The deletePackPromotion mutation can be used to delete an object of the PackPromotion class."
    deletePackPromotion(input: DeletePackPromotionInput!): DeletePackPromotionPayload
    "The deletePlace mutation can be used to delete an object of the Place class."
    deletePlace(input: DeletePlaceInput!): DeletePlacePayload
    "The deletePromotion mutation can be used to delete an object of the Promotion class."
    deletePromotion(input: DeletePromotionInput!): DeletePromotionPayload
    "The deleteRole mutation can be used to delete an object of the Role class."
    deleteRole(input: DeleteRoleInput!): DeleteRolePayload
    "The deleteSession mutation can be used to delete an object of the Session class."
    deleteSession(input: DeleteSessionInput!): DeleteSessionPayload
    "The deleteState mutation can be used to delete an object of the State class."
    deleteState(input: DeleteStateInput!): DeleteStatePayload
    "The deleteTour mutation can be used to delete an object of the Tour class."
    deleteTour(input: DeleteTourInput!): DeleteTourPayload
    "The deleteTourCategory mutation can be used to delete an object of the TourCategory class."
    deleteTourCategory(input: DeleteTourCategoryInput!): DeleteTourCategoryPayload
    "The deleteTourImage mutation can be used to delete an object of the TourImage class."
    deleteTourImage(input: DeleteTourImageInput!): DeleteTourImagePayload
    "The deleteTourPlace mutation can be used to delete an object of the TourPlace class."
    deleteTourPlace(input: DeleteTourPlaceInput!): DeleteTourPlacePayload
    "The deleteTourPromotion mutation can be used to delete an object of the TourPromotion class."
    deleteTourPromotion(input: DeleteTourPromotionInput!): DeleteTourPromotionPayload
    "The deleteToursInPack mutation can be used to delete an object of the ToursInPack class."
    deleteToursInPack(input: DeleteToursInPackInput!): DeleteToursInPackPayload
    "The deleteUser mutation can be used to delete an object of the User class."
    deleteUser(input: DeleteUserInput!): DeleteUserPayload
    "The logIn mutation can be used to log in an existing user."
    logIn(input: LogInInput!): LogInPayload
    "The logInWith mutation can be used to signup, login user with 3rd party authentication system. This mutation create a user if the authData do not correspond to an existing one."
    logInWith(input: LogInWithInput!): LogInWithPayload
    "The logOut mutation can be used to log out an existing user."
    logOut(input: LogOutInput!): LogOutPayload
    "The resetPassword mutation can be used to reset the password of an existing user."
    resetPassword(input: ResetPasswordInput!): ResetPasswordPayload
    "The sendVerificationEmail mutation can be used to send the verification email again."
    sendVerificationEmail(input: SendVerificationEmailInput!): SendVerificationEmailPayload
    "The signUp mutation can be used to create and sign up a new user."
    signUp(input: SignUpInput!): SignUpPayload
    "The updateB4aCustomField mutation can be used to update an object of the B4aCustomField class."
    updateB4aCustomField(input: UpdateB4aCustomFieldInput!): UpdateB4aCustomFieldPayload
    "The updateB4aMenuItem mutation can be used to update an object of the B4aMenuItem class."
    updateB4aMenuItem(input: UpdateB4aMenuItemInput!): UpdateB4aMenuItemPayload
    "The updateB4aSetting mutation can be used to update an object of the B4aSetting class."
    updateB4aSetting(input: UpdateB4aSettingInput!): UpdateB4aSettingPayload
    "The updateCategory mutation can be used to update an object of the Category class."
    updateCategory(input: UpdateCategoryInput!): UpdateCategoryPayload
    "The updateClass mutation can be used to update the schema for an existing object class."
    updateClass(input: UpdateClassInput!): UpdateClassPayload
    "The updateMyClass mutation can be used to update an object of the MyClass class."
    updateMyClass(input: UpdateMyClassInput!): UpdateMyClassPayload
    "The updatePack mutation can be used to update an object of the Pack class."
    updatePack(input: UpdatePackInput!): UpdatePackPayload
    "The updatePackPromotion mutation can be used to update an object of the PackPromotion class."
    updatePackPromotion(input: UpdatePackPromotionInput!): UpdatePackPromotionPayload
    "The updatePlace mutation can be used to update an object of the Place class."
    updatePlace(input: UpdatePlaceInput!): UpdatePlacePayload
    "The updatePromotion mutation can be used to update an object of the Promotion class."
    updatePromotion(input: UpdatePromotionInput!): UpdatePromotionPayload
    "The updateRole mutation can be used to update an object of the Role class."
    updateRole(input: UpdateRoleInput!): UpdateRolePayload
    "The updateSession mutation can be used to update an object of the Session class."
    updateSession(input: UpdateSessionInput!): UpdateSessionPayload
    "The updateState mutation can be used to update an object of the State class."
    updateState(input: UpdateStateInput!): UpdateStatePayload
    "The updateTour mutation can be used to update an object of the Tour class."
    updateTour(input: UpdateTourInput!): UpdateTourPayload
    "The updateTourCategory mutation can be used to update an object of the TourCategory class."
    updateTourCategory(input: UpdateTourCategoryInput!): UpdateTourCategoryPayload
    "The updateTourImage mutation can be used to update an object of the TourImage class."
    updateTourImage(input: UpdateTourImageInput!): UpdateTourImagePayload
    "The updateTourPlace mutation can be used to update an object of the TourPlace class."
    updateTourPlace(input: UpdateTourPlaceInput!): UpdateTourPlacePayload
    "The updateTourPromotion mutation can be used to update an object of the TourPromotion class."
    updateTourPromotion(input: UpdateTourPromotionInput!): UpdateTourPromotionPayload
    "The updateToursInPack mutation can be used to update an object of the ToursInPack class."
    updateToursInPack(input: UpdateToursInPackInput!): UpdateToursInPackPayload
    "The updateUser mutation can be used to update an object of the User class."
    updateUser(input: UpdateUserInput!): UpdateUserPayload
}

"The MyClass object type is used in operations that involve outputting objects of MyClass class."
type MyClass implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object myField."
    myField: String
    "This is the object id."
    objectId: ID!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type MyClassConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [MyClassEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type MyClassEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: MyClass
}

"The Pack object type is used in operations that involve outputting objects of Pack class."
type Pack implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object packDescription."
    packDescription: String!
    "This is the object packFeaturesExcluded."
    packFeaturesExcluded: String
    "This is the object packFeaturesIncluded."
    packFeaturesIncluded: String!
    "This is the object packImg."
    packImg: FileInfo!
    "This is the object packIsActive."
    packIsActive: Boolean!
    "This is the object packName."
    packName: String!
    "This is the object packPrice."
    packPrice: String!
    "This is the object packShortDescription."
    packShortDescription: String!
    "This is the object packThumb."
    packThumb: FileInfo!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type PackConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [PackEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type PackEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Pack
}

"The PackPromotion object type is used in operations that involve outputting objects of PackPromotion class."
type PackPromotion implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object packId."
    packId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [PackOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: PackWhereInput
    ): PackConnection!
    "This is the object promoId."
    promoId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [UserOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: UserWhereInput
    ): UserConnection!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type PackPromotionConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [PackPromotionEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type PackPromotionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: PackPromotion
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"The Place object type is used in operations that involve outputting objects of Place class."
type Place implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object placeDescription."
    placeDescription: String
    "This is the object placeImg."
    placeImg: FileInfo!
    "This is the object placeName."
    placeName: String!
    "This is the object placeShortDescription."
    placeShortDescription: String
    "This is the object placeThumb."
    placeThumb: FileInfo!
    "This is the object stateId."
    stateId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [StateOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: StateWhereInput
    ): StateConnection!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type PlaceConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [PlaceEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type PlaceEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Place
}

"The Promotion object type is used in operations that involve outputting objects of Promotion class."
type Promotion implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object promoDescription."
    promoDescription: String!
    "This is the object promoFeaturesExcluded."
    promoFeaturesExcluded: String
    "This is the object promoFeaturesIncluded."
    promoFeaturesIncluded: String!
    "This is the object promoImg."
    promoImg: FileInfo!
    "This is the object promoName."
    promoName: String
    "This is the object promoPrice."
    promoPrice: String!
    "This is the object promoThumb."
    promoThumb: FileInfo!
    "This is the object promoValidFrom."
    promoValidFrom: Date!
    "This is the object promoValidUntil."
    promoValidUntil: Date!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type PromotionConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [PromotionEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type PromotionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Promotion
}

"Allow to manage public rights."
type PublicACL {
    "Allow anyone to read the current object."
    read: Boolean
    "Allow anyone to write on the current object."
    write: Boolean
}

"Query is the top level type for queries."
type Query {
    "The b4aCustomField query can be used to get an object of the B4aCustomField class by its id."
    b4aCustomField(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): B4aCustomField!
    "The b4aCustomFields query can be used to find objects of the B4aCustomField class."
    b4aCustomFields(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [B4aCustomFieldOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: B4aCustomFieldWhereInput
    ): B4aCustomFieldConnection!
    "The b4aMenuItem query can be used to get an object of the B4aMenuItem class by its id."
    b4aMenuItem(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): B4aMenuItem!
    "The b4aMenuItems query can be used to find objects of the B4aMenuItem class."
    b4aMenuItems(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [B4aMenuItemOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: B4aMenuItemWhereInput
    ): B4aMenuItemConnection!
    "The b4aSetting query can be used to get an object of the B4aSetting class by its id."
    b4aSetting(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): B4aSetting!
    "The b4aSettings query can be used to find objects of the B4aSetting class."
    b4aSettings(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [B4aSettingOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: B4aSettingWhereInput
    ): B4aSettingConnection!
    "The categories query can be used to find objects of the Category class."
    categories(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [CategoryOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: CategoryWhereInput
    ): CategoryConnection!
    "The category query can be used to get an object of the Category class by its id."
    category(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): Category!
    "The class query can be used to retrieve an existing object class."
    class(
        "This is the name of the object class."
        name: String!
    ): Class!
    "The classes query can be used to retrieve the existing object classes."
    classes: [Class!]!
    "The health query can be used to check if the server is up and running."
    health: Boolean!
    "The myClass query can be used to get an object of the MyClass class by its id."
    myClass(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): MyClass!
    "The myClasses query can be used to find objects of the MyClass class."
    myClasses(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [MyClassOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: MyClassWhereInput
    ): MyClassConnection!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "The pack query can be used to get an object of the Pack class by its id."
    pack(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): Pack!
    "The packPromotion query can be used to get an object of the PackPromotion class by its id."
    packPromotion(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): PackPromotion!
    "The packPromotions query can be used to find objects of the PackPromotion class."
    packPromotions(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [PackPromotionOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: PackPromotionWhereInput
    ): PackPromotionConnection!
    "The packs query can be used to find objects of the Pack class."
    packs(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [PackOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: PackWhereInput
    ): PackConnection!
    "The place query can be used to get an object of the Place class by its id."
    place(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): Place!
    "The places query can be used to find objects of the Place class."
    places(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [PlaceOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: PlaceWhereInput
    ): PlaceConnection!
    "The promotion query can be used to get an object of the Promotion class by its id."
    promotion(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): Promotion!
    "The promotions query can be used to find objects of the Promotion class."
    promotions(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [PromotionOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: PromotionWhereInput
    ): PromotionConnection!
    "The role query can be used to get an object of the Role class by its id."
    role(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): Role!
    "The roles query can be used to find objects of the Role class."
    roles(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [RoleOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: RoleWhereInput
    ): RoleConnection!
    "The session query can be used to get an object of the Session class by its id."
    session(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): Session!
    "The sessions query can be used to find objects of the Session class."
    sessions(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [SessionOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: SessionWhereInput
    ): SessionConnection!
    "The state query can be used to get an object of the State class by its id."
    state(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): State!
    "The states query can be used to find objects of the State class."
    states(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [StateOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: StateWhereInput
    ): StateConnection!
    "The tour query can be used to get an object of the Tour class by its id."
    tour(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): Tour!
    "The tourCategories query can be used to find objects of the TourCategory class."
    tourCategories(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourCategoryOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourCategoryWhereInput
    ): TourCategoryConnection!
    "The tourCategory query can be used to get an object of the TourCategory class by its id."
    tourCategory(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): TourCategory!
    "The tourImage query can be used to get an object of the TourImage class by its id."
    tourImage(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): TourImage!
    "The tourImages query can be used to find objects of the TourImage class."
    tourImages(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourImageOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourImageWhereInput
    ): TourImageConnection!
    "The tourPlace query can be used to get an object of the TourPlace class by its id."
    tourPlace(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): TourPlace!
    "The tourPlaces query can be used to find objects of the TourPlace class."
    tourPlaces(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourPlaceOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourPlaceWhereInput
    ): TourPlaceConnection!
    "The tourPromotion query can be used to get an object of the TourPromotion class by its id."
    tourPromotion(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): TourPromotion!
    "The tourPromotions query can be used to find objects of the TourPromotion class."
    tourPromotions(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourPromotionOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourPromotionWhereInput
    ): TourPromotionConnection!
    "The tours query can be used to find objects of the Tour class."
    tours(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourWhereInput
    ): TourConnection!
    "The toursInPack query can be used to get an object of the ToursInPack class by its id."
    toursInPack(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): ToursInPack!
    "The toursInPacks query can be used to find objects of the ToursInPack class."
    toursInPacks(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [ToursInPackOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: ToursInPackWhereInput
    ): ToursInPackConnection!
    "The user query can be used to get an object of the User class by its id."
    user(
        "This is the object id. You can use either the global or the object id."
        id: ID!,
        "The read options for the query to be executed."
        options: ReadOptionsInput
    ): User!
    "The users query can be used to find objects of the User class."
    users(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [UserOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: UserWhereInput
    ): UserConnection!
    "The viewer query can be used to return the current user data."
    viewer: Viewer!
}

type ResetPasswordPayload {
    clientMutationId: String
    "It's always true."
    ok: Boolean!
}

"The Role object type is used in operations that involve outputting objects of Role class."
type Role implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object name."
    name: String
    "This is the object id."
    objectId: ID!
    "This is the object roles."
    roles(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [RoleOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: RoleWhereInput
    ): RoleConnection!
    "This is the date in which the object was las updated."
    updatedAt: Date!
    "This is the object users."
    users(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [UserOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: UserWhereInput
    ): UserConnection!
}

"Allow to manage roles in ACL. If read and write are null the role have read and write rights."
type RoleACL {
    "Allow users who are members of the role to read the current object."
    read: Boolean!
    "Name of the targetted Role."
    roleName: ID!
    "Allow users who are members of the role to write on the current object."
    write: Boolean!
}

"A connection to a list of items."
type RoleConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [RoleEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type RoleEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Role
}

"The SchemaACLField is used to return information of an ACL field."
type SchemaACLField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaArrayField is used to return information of an Array field."
type SchemaArrayField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaBooleanField is used to return information of a Boolean field."
type SchemaBooleanField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaBytesField is used to return information of a Bytes field."
type SchemaBytesField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaDateField is used to return information of a Date field."
type SchemaDateField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaFileField is used to return information of a File field."
type SchemaFileField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaGeoPointField is used to return information of a Geo Point field."
type SchemaGeoPointField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaNumberField is used to return information of a Number field."
type SchemaNumberField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaObjectField is used to return information of an Object field."
type SchemaObjectField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaPointerField is used to return information of a Pointer field."
type SchemaPointerField implements SchemaField {
    "This is the field name."
    name: String!
    "This is the name of the target class for the field."
    targetClassName: String!
}

"The SchemaPolygonField is used to return information of a Polygon field."
type SchemaPolygonField implements SchemaField {
    "This is the field name."
    name: String!
}

"The SchemaRelationField is used to return information of a Relation field."
type SchemaRelationField implements SchemaField {
    "This is the field name."
    name: String!
    "This is the name of the target class for the field."
    targetClassName: String!
}

"The SchemaStringField is used to return information of a String field."
type SchemaStringField implements SchemaField {
    "This is the field name."
    name: String!
}

type SendVerificationEmailPayload {
    clientMutationId: String
    "It's always true."
    ok: Boolean!
}

"The Session object type is used in operations that involve outputting objects of Session class."
type Session implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "This is the object createdWith."
    createdWith: Object
    "This is the object expiresAt."
    expiresAt: Date
    "The ID of an object"
    id: ID!
    "This is the object installationId."
    installationId: String
    "This is the object id."
    objectId: ID!
    "This is the object restricted."
    restricted: Boolean
    "This is the object sessionToken."
    sessionToken: String
    "This is the date in which the object was las updated."
    updatedAt: Date!
    "This is the object user."
    user: User
}

"A connection to a list of items."
type SessionConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [SessionEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type SessionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Session
}

type SignUpPayload {
    clientMutationId: String
    "This is the new user that was created, signed up and returned as a viewer."
    viewer: Viewer!
}

"The State object type is used in operations that involve outputting objects of State class."
type State implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object stateAbbr."
    stateAbbr: String!
    "This is the object stateImg."
    stateImg: FileInfo!
    "This is the object stateName."
    stateName: String!
    "This is the object stateThumb."
    stateThumb: FileInfo!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type StateConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [StateEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type StateEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: State
}

"The Tour object type is used in operations that involve outputting objects of Tour class."
type Tour implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object tourDescription."
    tourDescription: String!
    "This is the object tourFeaturesExcluded."
    tourFeaturesExcluded: String
    "This is the object tourFeaturesIncluded."
    tourFeaturesIncluded: String!
    "This is the object tourIsActive."
    tourIsActive: Boolean!
    "This is the object tourName."
    tourName: String!
    "This is the object tourPrice."
    tourPrice: String!
    "This is the object tourShortDescription."
    tourShortDescription: String!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"The TourCategory object type is used in operations that involve outputting objects of TourCategory class."
type TourCategory implements Node & ParseObject {
    ACL: ACL!
    "This is the object categoryId."
    categoryId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [CategoryOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: CategoryWhereInput
    ): CategoryConnection!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object tourId."
    tourId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourWhereInput
    ): TourConnection!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type TourCategoryConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [TourCategoryEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type TourCategoryEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: TourCategory
}

"A connection to a list of items."
type TourConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [TourEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type TourEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Tour
}

"The TourImage object type is used in operations that involve outputting objects of TourImage class."
type TourImage implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object tourId."
    tourId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourWhereInput
    ): TourConnection!
    "This is the object tourImg."
    tourImg: FileInfo!
    "This is the object tourThumb."
    tourThumb: FileInfo!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type TourImageConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [TourImageEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type TourImageEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: TourImage
}

"The TourPlace object type is used in operations that involve outputting objects of TourPlace class."
type TourPlace implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object placeId."
    placeId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [PlaceOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: PlaceWhereInput
    ): PlaceConnection!
    "This is the object tourId."
    tourId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourWhereInput
    ): TourConnection!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type TourPlaceConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [TourPlaceEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type TourPlaceEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: TourPlace
}

"The TourPromotion object type is used in operations that involve outputting objects of TourPromotion class."
type TourPromotion implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object promoId."
    promoId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [PromotionOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: PromotionWhereInput
    ): PromotionConnection!
    "This is the object tourId."
    tourId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourWhereInput
    ): TourConnection!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type TourPromotionConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [TourPromotionEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type TourPromotionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: TourPromotion
}

"The ToursInPack object type is used in operations that involve outputting objects of ToursInPack class."
type ToursInPack implements Node & ParseObject {
    ACL: ACL!
    "This is the date in which the object was created."
    createdAt: Date!
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the object packId."
    packId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [PackOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: PackWhereInput
    ): PackConnection!
    "This is the object tourId."
    tourId(
        after: String,
        before: String,
        first: Int,
        last: Int,
        "The read options for the query to be executed."
        options: ReadOptionsInput,
        "The fields to be used when sorting the data fetched."
        order: [TourOrder!],
        "This is the number of objects that must be skipped to return."
        skip: Int,
        "These are the conditions that the objects need to match in order to be found."
        where: TourWhereInput
    ): TourConnection!
    "This is the date in which the object was las updated."
    updatedAt: Date!
}

"A connection to a list of items."
type ToursInPackConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [ToursInPackEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ToursInPackEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: ToursInPack
}

type UpdateB4aCustomFieldPayload {
    "This is the updated object."
    b4aCustomField: B4aCustomField!
    clientMutationId: String
}

type UpdateB4aMenuItemPayload {
    "This is the updated object."
    b4aMenuItem: B4aMenuItem!
    clientMutationId: String
}

type UpdateB4aSettingPayload {
    "This is the updated object."
    b4aSetting: B4aSetting!
    clientMutationId: String
}

type UpdateCategoryPayload {
    "This is the updated object."
    category: Category!
    clientMutationId: String
}

type UpdateClassPayload {
    "This is the updated class."
    class: Class!
    clientMutationId: String
}

type UpdateMyClassPayload {
    clientMutationId: String
    "This is the updated object."
    myClass: MyClass!
}

type UpdatePackPayload {
    clientMutationId: String
    "This is the updated object."
    pack: Pack!
}

type UpdatePackPromotionPayload {
    clientMutationId: String
    "This is the updated object."
    packPromotion: PackPromotion!
}

type UpdatePlacePayload {
    clientMutationId: String
    "This is the updated object."
    place: Place!
}

type UpdatePromotionPayload {
    clientMutationId: String
    "This is the updated object."
    promotion: Promotion!
}

type UpdateRolePayload {
    clientMutationId: String
    "This is the updated object."
    role: Role!
}

type UpdateSessionPayload {
    clientMutationId: String
    "This is the updated object."
    session: Session!
}

type UpdateStatePayload {
    clientMutationId: String
    "This is the updated object."
    state: State!
}

type UpdateTourCategoryPayload {
    clientMutationId: String
    "This is the updated object."
    tourCategory: TourCategory!
}

type UpdateTourImagePayload {
    clientMutationId: String
    "This is the updated object."
    tourImage: TourImage!
}

type UpdateTourPayload {
    clientMutationId: String
    "This is the updated object."
    tour: Tour!
}

type UpdateTourPlacePayload {
    clientMutationId: String
    "This is the updated object."
    tourPlace: TourPlace!
}

type UpdateTourPromotionPayload {
    clientMutationId: String
    "This is the updated object."
    tourPromotion: TourPromotion!
}

type UpdateToursInPackPayload {
    clientMutationId: String
    "This is the updated object."
    toursInPack: ToursInPack!
}

type UpdateUserPayload {
    clientMutationId: String
    "This is the updated object."
    user: User!
}

"The User object type is used in operations that involve outputting objects of User class."
type User implements Node & ParseObject {
    ACL: ACL!
    "This is the object authData."
    authData: Object
    "This is the date in which the object was created."
    createdAt: Date!
    "This is the object email."
    email: String
    "This is the object emailVerified."
    emailVerified: Boolean
    "The ID of an object"
    id: ID!
    "This is the object id."
    objectId: ID!
    "This is the date in which the object was las updated."
    updatedAt: Date!
    "This is the object username."
    username: String
}

"Allow to manage users in ACL. If read and write are null the users have read and write rights."
type UserACL {
    "Allow the user to read the current object."
    read: Boolean!
    "ID of the targetted User."
    userId: ID!
    "Allow the user to write on the current object."
    write: Boolean!
}

"A connection to a list of items."
type UserConnection {
    "This is the total matched objecs count that is returned when the count flag is set."
    count: Int!
    "A list of edges."
    edges: [UserEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type UserEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: User
}

"The Viewer object type is used in operations that involve outputting the current user data."
type Viewer {
    "The current user session token."
    sessionToken: String!
    "This is the current user."
    user: User!
}

"The B4aCustomFieldOrder input type is used when sorting objects of the B4aCustomField class."
enum B4aCustomFieldOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    cssClassName_ASC
    cssClassName_DESC
    defaultValue_ASC
    defaultValue_DESC
    id_ASC
    id_DESC
    inputMask_ASC
    inputMask_DESC
    isFormHidden_ASC
    isFormHidden_DESC
    isRequired_ASC
    isRequired_DESC
    isTableHidden_ASC
    isTableHidden_DESC
    objectClassFieldName_ASC
    objectClassFieldName_DESC
    objectClassName_ASC
    objectClassName_DESC
    objectId_ASC
    objectId_DESC
    options_ASC
    options_DESC
    referenceTitleField_ASC
    referenceTitleField_DESC
    referencesLinkText_ASC
    referencesLinkText_DESC
    referencesLinkTitle_ASC
    referencesLinkTitle_DESC
    relevance_ASC
    relevance_DESC
    subType_ASC
    subType_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The B4aMenuItemOrder input type is used when sorting objects of the B4aMenuItem class."
enum B4aMenuItemOrder {
    ACL_ASC
    ACL_DESC
    addFormTitle_ASC
    addFormTitle_DESC
    createdAt_ASC
    createdAt_DESC
    editFormTitle_ASC
    editFormTitle_DESC
    id_ASC
    id_DESC
    isHidden_ASC
    isHidden_DESC
    isReadOnly_ASC
    isReadOnly_DESC
    objectClassName_ASC
    objectClassName_DESC
    objectId_ASC
    objectId_DESC
    relevance_ASC
    relevance_DESC
    title_ASC
    title_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The B4aSettingOrder input type is used when sorting objects of the B4aSetting class."
enum B4aSettingOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    key_ASC
    key_DESC
    objectId_ASC
    objectId_DESC
    updatedAt_ASC
    updatedAt_DESC
    value_ASC
    value_DESC
}

"The CategoryOrder input type is used when sorting objects of the Category class."
enum CategoryOrder {
    ACL_ASC
    ACL_DESC
    categoryIconType_ASC
    categoryIconType_DESC
    categoryIcon_ASC
    categoryIcon_DESC
    categoryImg_ASC
    categoryImg_DESC
    categoryName_ASC
    categoryName_DESC
    categoryThumb_ASC
    categoryThumb_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The MyClassOrder input type is used when sorting objects of the MyClass class."
enum MyClassOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    myField_ASC
    myField_DESC
    objectId_ASC
    objectId_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The PackOrder input type is used when sorting objects of the Pack class."
enum PackOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    packDescription_ASC
    packDescription_DESC
    packFeaturesExcluded_ASC
    packFeaturesExcluded_DESC
    packFeaturesIncluded_ASC
    packFeaturesIncluded_DESC
    packImg_ASC
    packImg_DESC
    packIsActive_ASC
    packIsActive_DESC
    packName_ASC
    packName_DESC
    packPrice_ASC
    packPrice_DESC
    packShortDescription_ASC
    packShortDescription_DESC
    packThumb_ASC
    packThumb_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The PackPromotionOrder input type is used when sorting objects of the PackPromotion class."
enum PackPromotionOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    packId_ASC
    packId_DESC
    promoId_ASC
    promoId_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The PlaceOrder input type is used when sorting objects of the Place class."
enum PlaceOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    placeDescription_ASC
    placeDescription_DESC
    placeImg_ASC
    placeImg_DESC
    placeName_ASC
    placeName_DESC
    placeShortDescription_ASC
    placeShortDescription_DESC
    placeThumb_ASC
    placeThumb_DESC
    stateId_ASC
    stateId_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The PromotionOrder input type is used when sorting objects of the Promotion class."
enum PromotionOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    promoDescription_ASC
    promoDescription_DESC
    promoFeaturesExcluded_ASC
    promoFeaturesExcluded_DESC
    promoFeaturesIncluded_ASC
    promoFeaturesIncluded_DESC
    promoImg_ASC
    promoImg_DESC
    promoName_ASC
    promoName_DESC
    promoPrice_ASC
    promoPrice_DESC
    promoThumb_ASC
    promoThumb_DESC
    promoValidFrom_ASC
    promoValidFrom_DESC
    promoValidUntil_ASC
    promoValidUntil_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The ReadPreference enum type is used in queries in order to select in which database replica the operation must run."
enum ReadPreference {
    NEAREST
    PRIMARY
    PRIMARY_PREFERRED
    SECONDARY
    SECONDARY_PREFERRED
}

"The RoleOrder input type is used when sorting objects of the Role class."
enum RoleOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    objectId_ASC
    objectId_DESC
    roles_ASC
    roles_DESC
    updatedAt_ASC
    updatedAt_DESC
    users_ASC
    users_DESC
}

"The SessionOrder input type is used when sorting objects of the Session class."
enum SessionOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    createdWith_ASC
    createdWith_DESC
    expiresAt_ASC
    expiresAt_DESC
    id_ASC
    id_DESC
    installationId_ASC
    installationId_DESC
    objectId_ASC
    objectId_DESC
    restricted_ASC
    restricted_DESC
    sessionToken_ASC
    sessionToken_DESC
    updatedAt_ASC
    updatedAt_DESC
    user_ASC
    user_DESC
}

"The StateOrder input type is used when sorting objects of the State class."
enum StateOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    stateAbbr_ASC
    stateAbbr_DESC
    stateImg_ASC
    stateImg_DESC
    stateName_ASC
    stateName_DESC
    stateThumb_ASC
    stateThumb_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The TourCategoryOrder input type is used when sorting objects of the TourCategory class."
enum TourCategoryOrder {
    ACL_ASC
    ACL_DESC
    categoryId_ASC
    categoryId_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    tourId_ASC
    tourId_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The TourImageOrder input type is used when sorting objects of the TourImage class."
enum TourImageOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    tourId_ASC
    tourId_DESC
    tourImg_ASC
    tourImg_DESC
    tourThumb_ASC
    tourThumb_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The TourOrder input type is used when sorting objects of the Tour class."
enum TourOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    tourDescription_ASC
    tourDescription_DESC
    tourFeaturesExcluded_ASC
    tourFeaturesExcluded_DESC
    tourFeaturesIncluded_ASC
    tourFeaturesIncluded_DESC
    tourIsActive_ASC
    tourIsActive_DESC
    tourName_ASC
    tourName_DESC
    tourPrice_ASC
    tourPrice_DESC
    tourShortDescription_ASC
    tourShortDescription_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The TourPlaceOrder input type is used when sorting objects of the TourPlace class."
enum TourPlaceOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    placeId_ASC
    placeId_DESC
    tourId_ASC
    tourId_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The TourPromotionOrder input type is used when sorting objects of the TourPromotion class."
enum TourPromotionOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    promoId_ASC
    promoId_DESC
    tourId_ASC
    tourId_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The ToursInPackOrder input type is used when sorting objects of the ToursInPack class."
enum ToursInPackOrder {
    ACL_ASC
    ACL_DESC
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    packId_ASC
    packId_DESC
    tourId_ASC
    tourId_DESC
    updatedAt_ASC
    updatedAt_DESC
}

"The UserOrder input type is used when sorting objects of the User class."
enum UserOrder {
    ACL_ASC
    ACL_DESC
    authData_ASC
    authData_DESC
    createdAt_ASC
    createdAt_DESC
    emailVerified_ASC
    emailVerified_DESC
    email_ASC
    email_DESC
    id_ASC
    id_DESC
    objectId_ASC
    objectId_DESC
    password_ASC
    password_DESC
    updatedAt_ASC
    updatedAt_DESC
    username_ASC
    username_DESC
}

"The Any scalar type is used in operations and types that involve any type of value."
scalar Any

"The Bytes scalar type is used in operations and types that involve base 64 binary data."
scalar Bytes

"The Date scalar type is used in operations and types that involve dates."
scalar Date

"The File scalar type is used in operations and types that involve files."
scalar File

"The Object scalar type is used in operations and types that involve objects."
scalar Object

"The `Upload` scalar type represents a file upload."
scalar Upload

"Allow to manage access rights. If not provided object will be publicly readable and writable"
input ACLInput {
    "Public access control list."
    public: PublicACLInput
    "Access control list for roles."
    roles: [RoleACLInput!]
    "Access control list for users."
    users: [UserACLInput!]
}

"The ArrayWhereInput input type is used in operations that involve filtering objects by a field of type Array."
input ArrayWhereInput {
    "This is the containedBy operator to specify a constraint to select the objects where the values of an array field is contained by another specified array."
    containedBy: [Any]
    "This is the contains operator to specify a constraint to select the objects where the values of an array field contain all elements of another specified array."
    contains: [Any]
    "This is the equalTo operator to specify a constraint to select the objects where the value of a field equals to a specified value."
    equalTo: Any
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the greaterThan operator to specify a constraint to select the objects where the value of a field is greater than a specified value."
    greaterThan: Any
    "This is the greaterThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is greater than or equal to a specified value."
    greaterThanOrEqualTo: Any
    "This is the in operator to specify a constraint to select the objects where the value of a field equals any value in the specified array."
    in: [Any]
    "This is the inQueryKey operator to specify a constraint to select the objects where a field equals to a key in the result of a different query."
    inQueryKey: SelectInput
    "This is the lessThan operator to specify a constraint to select the objects where the value of a field is less than a specified value."
    lessThan: Any
    "This is the lessThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is less than or equal to a specified value."
    lessThanOrEqualTo: Any
    "This is the notEqualTo operator to specify a constraint to select the objects where the value of a field do not equal to a specified value."
    notEqualTo: Any
    "This is the notIn operator to specify a constraint to select the objects where the value of a field do not equal any value in the specified array."
    notIn: [Any]
    "This is the notInQueryKey operator to specify a constraint to select the objects where a field do not equal to a key in the result of a different query."
    notInQueryKey: SelectInput
}

"Allow to link OR add and link an object of the B4aCustomField class."
input B4aCustomFieldPointerInput {
    "Create and link an object from B4aCustomField class."
    createAndLink: CreateB4aCustomFieldFieldsInput
    "Link an existing object from B4aCustomField class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the B4aCustomField class into a relation field."
input B4aCustomFieldRelationInput {
    "Add existing objects from the B4aCustomField class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the B4aCustomField class into the relation."
    createAndAdd: [CreateB4aCustomFieldFieldsInput!]
    "Remove existing objects from the B4aCustomField class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The B4aCustomFieldRelationWhereInput input type is used in operations that involve filtering objects of B4aCustomField class."
input B4aCustomFieldRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: B4aCustomFieldWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: B4aCustomFieldWhereInput
}

"The B4aCustomFieldWhereInput input type is used in operations that involve filtering objects of B4aCustomField class."
input B4aCustomFieldWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [B4aCustomFieldWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [B4aCustomFieldWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [B4aCustomFieldWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object cssClassName."
    cssClassName: StringWhereInput
    "This is the object defaultValue."
    defaultValue: StringWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object inputMask."
    inputMask: StringWhereInput
    "This is the object isFormHidden."
    isFormHidden: StringWhereInput
    "This is the object isRequired."
    isRequired: BooleanWhereInput
    "This is the object isTableHidden."
    isTableHidden: BooleanWhereInput
    "This is the object objectClassFieldName."
    objectClassFieldName: StringWhereInput
    "This is the object objectClassName."
    objectClassName: StringWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object options."
    options: StringWhereInput
    "This is the object referenceTitleField."
    referenceTitleField: StringWhereInput
    "This is the object referencesLinkText."
    referencesLinkText: StringWhereInput
    "This is the object referencesLinkTitle."
    referencesLinkTitle: StringWhereInput
    "This is the object relevance."
    relevance: NumberWhereInput
    "This is the object subType."
    subType: StringWhereInput
    "This is the object title."
    title: StringWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to link OR add and link an object of the B4aMenuItem class."
input B4aMenuItemPointerInput {
    "Create and link an object from B4aMenuItem class."
    createAndLink: CreateB4aMenuItemFieldsInput
    "Link an existing object from B4aMenuItem class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the B4aMenuItem class into a relation field."
input B4aMenuItemRelationInput {
    "Add existing objects from the B4aMenuItem class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the B4aMenuItem class into the relation."
    createAndAdd: [CreateB4aMenuItemFieldsInput!]
    "Remove existing objects from the B4aMenuItem class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The B4aMenuItemRelationWhereInput input type is used in operations that involve filtering objects of B4aMenuItem class."
input B4aMenuItemRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: B4aMenuItemWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: B4aMenuItemWhereInput
}

"The B4aMenuItemWhereInput input type is used in operations that involve filtering objects of B4aMenuItem class."
input B4aMenuItemWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [B4aMenuItemWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [B4aMenuItemWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [B4aMenuItemWhereInput!]
    "This is the object addFormTitle."
    addFormTitle: StringWhereInput
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object editFormTitle."
    editFormTitle: StringWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object isHidden."
    isHidden: BooleanWhereInput
    "This is the object isReadOnly."
    isReadOnly: BooleanWhereInput
    "This is the object objectClassName."
    objectClassName: StringWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object relevance."
    relevance: StringWhereInput
    "This is the object title."
    title: StringWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to link OR add and link an object of the B4aSetting class."
input B4aSettingPointerInput {
    "Create and link an object from B4aSetting class."
    createAndLink: CreateB4aSettingFieldsInput
    "Link an existing object from B4aSetting class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the B4aSetting class into a relation field."
input B4aSettingRelationInput {
    "Add existing objects from the B4aSetting class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the B4aSetting class into the relation."
    createAndAdd: [CreateB4aSettingFieldsInput!]
    "Remove existing objects from the B4aSetting class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The B4aSettingRelationWhereInput input type is used in operations that involve filtering objects of B4aSetting class."
input B4aSettingRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: B4aSettingWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: B4aSettingWhereInput
}

"The B4aSettingWhereInput input type is used in operations that involve filtering objects of B4aSetting class."
input B4aSettingWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [B4aSettingWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [B4aSettingWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [B4aSettingWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object key."
    key: StringWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
    "This is the object value."
    value: StringWhereInput
}

"The BooleanWhereInput input type is used in operations that involve filtering objects by a field of type Boolean."
input BooleanWhereInput {
    "This is the equalTo operator to specify a constraint to select the objects where the value of a field equals to a specified value."
    equalTo: Boolean
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the inQueryKey operator to specify a constraint to select the objects where a field equals to a key in the result of a different query."
    inQueryKey: SelectInput
    "This is the notEqualTo operator to specify a constraint to select the objects where the value of a field do not equal to a specified value."
    notEqualTo: Boolean
    "This is the notInQueryKey operator to specify a constraint to select the objects where a field do not equal to a key in the result of a different query."
    notInQueryKey: SelectInput
}

"The BoxInput type is used to specifiy a box operation on a within geo query."
input BoxInput {
    "This is the bottom left coordinates of the box."
    bottomLeft: GeoPointInput!
    "This is the upper right coordinates of the box."
    upperRight: GeoPointInput!
}

"The BytesWhereInput input type is used in operations that involve filtering objects by a field of type Bytes."
input BytesWhereInput {
    "This is the equalTo operator to specify a constraint to select the objects where the value of a field equals to a specified value."
    equalTo: Bytes
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the greaterThan operator to specify a constraint to select the objects where the value of a field is greater than a specified value."
    greaterThan: Bytes
    "This is the greaterThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is greater than or equal to a specified value."
    greaterThanOrEqualTo: Bytes
    "This is the in operator to specify a constraint to select the objects where the value of a field equals any value in the specified array."
    in: [Bytes]
    "This is the inQueryKey operator to specify a constraint to select the objects where a field equals to a key in the result of a different query."
    inQueryKey: SelectInput
    "This is the lessThan operator to specify a constraint to select the objects where the value of a field is less than a specified value."
    lessThan: Bytes
    "This is the lessThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is less than or equal to a specified value."
    lessThanOrEqualTo: Bytes
    "This is the notEqualTo operator to specify a constraint to select the objects where the value of a field do not equal to a specified value."
    notEqualTo: Bytes
    "This is the notIn operator to specify a constraint to select the objects where the value of a field do not equal any value in the specified array."
    notIn: [Bytes]
    "This is the notInQueryKey operator to specify a constraint to select the objects where a field do not equal to a key in the result of a different query."
    notInQueryKey: SelectInput
}

"Allow to link OR add and link an object of the Category class."
input CategoryPointerInput {
    "Create and link an object from Category class."
    createAndLink: CreateCategoryFieldsInput
    "Link an existing object from Category class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the Category class into a relation field."
input CategoryRelationInput {
    "Add existing objects from the Category class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the Category class into the relation."
    createAndAdd: [CreateCategoryFieldsInput!]
    "Remove existing objects from the Category class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The CategoryRelationWhereInput input type is used in operations that involve filtering objects of Category class."
input CategoryRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: CategoryWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: CategoryWhereInput
}

"The CategoryWhereInput input type is used in operations that involve filtering objects of Category class."
input CategoryWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [CategoryWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [CategoryWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [CategoryWhereInput!]
    "This is the object categoryIcon."
    categoryIcon: StringWhereInput
    "This is the object categoryIconType."
    categoryIconType: NumberWhereInput
    "This is the object categoryImg."
    categoryImg: FileWhereInput
    "This is the object categoryName."
    categoryName: StringWhereInput
    "This is the object categoryThumb."
    categoryThumb: FileWhereInput
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"The CenterSphereInput type is used to specifiy a centerSphere operation on a geoWithin query."
input CenterSphereInput {
    "This is the center of the sphere."
    center: GeoPointInput!
    "This is the radius of the sphere."
    distance: Float!
}

"The CreateB4aCustomFieldFieldsInput input type is used in operations that involve creation of objects in the B4aCustomField class."
input CreateB4aCustomFieldFieldsInput {
    ACL: ACLInput
    "This is the object cssClassName."
    cssClassName: String
    "This is the object defaultValue."
    defaultValue: String
    "This is the object inputMask."
    inputMask: String
    "This is the object isFormHidden."
    isFormHidden: String
    "This is the object isRequired."
    isRequired: Boolean
    "This is the object isTableHidden."
    isTableHidden: Boolean
    "This is the object objectClassFieldName."
    objectClassFieldName: String
    "This is the object objectClassName."
    objectClassName: String
    "This is the object options."
    options: String
    "This is the object referenceTitleField."
    referenceTitleField: String
    "This is the object referencesLinkText."
    referencesLinkText: String
    "This is the object referencesLinkTitle."
    referencesLinkTitle: String
    "This is the object relevance."
    relevance: Float
    "This is the object subType."
    subType: String
    "This is the object title."
    title: String
}

input CreateB4aCustomFieldInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateB4aCustomFieldFieldsInput
}

"The CreateB4aMenuItemFieldsInput input type is used in operations that involve creation of objects in the B4aMenuItem class."
input CreateB4aMenuItemFieldsInput {
    ACL: ACLInput
    "This is the object addFormTitle."
    addFormTitle: String
    "This is the object editFormTitle."
    editFormTitle: String
    "This is the object isHidden."
    isHidden: Boolean
    "This is the object isReadOnly."
    isReadOnly: Boolean
    "This is the object objectClassName."
    objectClassName: String
    "This is the object relevance."
    relevance: String
    "This is the object title."
    title: String
}

input CreateB4aMenuItemInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateB4aMenuItemFieldsInput
}

"The CreateB4aSettingFieldsInput input type is used in operations that involve creation of objects in the B4aSetting class."
input CreateB4aSettingFieldsInput {
    ACL: ACLInput
    "This is the object key."
    key: String
    "This is the object value."
    value: String
}

input CreateB4aSettingInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateB4aSettingFieldsInput
}

"The CreateCategoryFieldsInput input type is used in operations that involve creation of objects in the Category class."
input CreateCategoryFieldsInput {
    ACL: ACLInput
    "This is the object categoryIcon."
    categoryIcon: String!
    "This is the object categoryIconType."
    categoryIconType: Float!
    "This is the object categoryImg."
    categoryImg: FileInput!
    "This is the object categoryName."
    categoryName: String!
    "This is the object categoryThumb."
    categoryThumb: FileInput!
}

input CreateCategoryInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateCategoryFieldsInput
}

input CreateClassInput {
    clientMutationId: String
    "This is the name of the object class."
    name: String!
    "These are the schema's fields of the object class."
    schemaFields: SchemaFieldsInput
}

input CreateFileInput {
    clientMutationId: String
    "This is the new file to be created and uploaded."
    upload: Upload!
}

"The CreateMyClassFieldsInput input type is used in operations that involve creation of objects in the MyClass class."
input CreateMyClassFieldsInput {
    ACL: ACLInput
    "This is the object myField."
    myField: String
}

input CreateMyClassInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateMyClassFieldsInput
}

"The CreatePackFieldsInput input type is used in operations that involve creation of objects in the Pack class."
input CreatePackFieldsInput {
    ACL: ACLInput
    "This is the object packDescription."
    packDescription: String!
    "This is the object packFeaturesExcluded."
    packFeaturesExcluded: String
    "This is the object packFeaturesIncluded."
    packFeaturesIncluded: String!
    "This is the object packImg."
    packImg: FileInput!
    "This is the object packIsActive."
    packIsActive: Boolean!
    "This is the object packName."
    packName: String!
    "This is the object packPrice."
    packPrice: String!
    "This is the object packShortDescription."
    packShortDescription: String!
    "This is the object packThumb."
    packThumb: FileInput!
}

input CreatePackInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreatePackFieldsInput
}

"The CreatePackPromotionFieldsInput input type is used in operations that involve creation of objects in the PackPromotion class."
input CreatePackPromotionFieldsInput {
    ACL: ACLInput
    "This is the object packId."
    packId: PackRelationInput
    "This is the object promoId."
    promoId: UserRelationInput
}

input CreatePackPromotionInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreatePackPromotionFieldsInput
}

"The CreatePlaceFieldsInput input type is used in operations that involve creation of objects in the Place class."
input CreatePlaceFieldsInput {
    ACL: ACLInput
    "This is the object placeDescription."
    placeDescription: String
    "This is the object placeImg."
    placeImg: FileInput!
    "This is the object placeName."
    placeName: String!
    "This is the object placeShortDescription."
    placeShortDescription: String
    "This is the object placeThumb."
    placeThumb: FileInput!
    "This is the object stateId."
    stateId: StateRelationInput
}

input CreatePlaceInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreatePlaceFieldsInput
}

"The CreatePromotionFieldsInput input type is used in operations that involve creation of objects in the Promotion class."
input CreatePromotionFieldsInput {
    ACL: ACLInput
    "This is the object promoDescription."
    promoDescription: String!
    "This is the object promoFeaturesExcluded."
    promoFeaturesExcluded: String
    "This is the object promoFeaturesIncluded."
    promoFeaturesIncluded: String!
    "This is the object promoImg."
    promoImg: FileInput!
    "This is the object promoName."
    promoName: String
    "This is the object promoPrice."
    promoPrice: String!
    "This is the object promoThumb."
    promoThumb: FileInput!
    "This is the object promoValidFrom."
    promoValidFrom: Date!
    "This is the object promoValidUntil."
    promoValidUntil: Date!
}

input CreatePromotionInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreatePromotionFieldsInput
}

"The CreateRoleFieldsInput input type is used in operations that involve creation of objects in the Role class."
input CreateRoleFieldsInput {
    ACL: ACLInput
    "This is the object name."
    name: String
    "This is the object roles."
    roles: RoleRelationInput
    "This is the object users."
    users: UserRelationInput
}

input CreateRoleInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateRoleFieldsInput
}

"The CreateSessionFieldsInput input type is used in operations that involve creation of objects in the Session class."
input CreateSessionFieldsInput {
    ACL: ACLInput
    "This is the object createdWith."
    createdWith: Object
    "This is the object expiresAt."
    expiresAt: Date
    "This is the object installationId."
    installationId: String
    "This is the object restricted."
    restricted: Boolean
    "This is the object sessionToken."
    sessionToken: String
    "This is the object user."
    user: UserPointerInput
}

input CreateSessionInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateSessionFieldsInput
}

"The CreateStateFieldsInput input type is used in operations that involve creation of objects in the State class."
input CreateStateFieldsInput {
    ACL: ACLInput
    "This is the object stateAbbr."
    stateAbbr: String!
    "This is the object stateImg."
    stateImg: FileInput!
    "This is the object stateName."
    stateName: String!
    "This is the object stateThumb."
    stateThumb: FileInput!
}

input CreateStateInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateStateFieldsInput
}

"The CreateTourCategoryFieldsInput input type is used in operations that involve creation of objects in the TourCategory class."
input CreateTourCategoryFieldsInput {
    ACL: ACLInput
    "This is the object categoryId."
    categoryId: CategoryRelationInput
    "This is the object tourId."
    tourId: TourRelationInput
}

input CreateTourCategoryInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateTourCategoryFieldsInput
}

"The CreateTourFieldsInput input type is used in operations that involve creation of objects in the Tour class."
input CreateTourFieldsInput {
    ACL: ACLInput
    "This is the object tourDescription."
    tourDescription: String!
    "This is the object tourFeaturesExcluded."
    tourFeaturesExcluded: String
    "This is the object tourFeaturesIncluded."
    tourFeaturesIncluded: String!
    "This is the object tourIsActive."
    tourIsActive: Boolean!
    "This is the object tourName."
    tourName: String!
    "This is the object tourPrice."
    tourPrice: String!
    "This is the object tourShortDescription."
    tourShortDescription: String!
}

"The CreateTourImageFieldsInput input type is used in operations that involve creation of objects in the TourImage class."
input CreateTourImageFieldsInput {
    ACL: ACLInput
    "This is the object tourId."
    tourId: TourRelationInput
    "This is the object tourImg."
    tourImg: FileInput!
    "This is the object tourThumb."
    tourThumb: FileInput!
}

input CreateTourImageInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateTourImageFieldsInput
}

input CreateTourInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateTourFieldsInput
}

"The CreateTourPlaceFieldsInput input type is used in operations that involve creation of objects in the TourPlace class."
input CreateTourPlaceFieldsInput {
    ACL: ACLInput
    "This is the object placeId."
    placeId: PlaceRelationInput
    "This is the object tourId."
    tourId: TourRelationInput
}

input CreateTourPlaceInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateTourPlaceFieldsInput
}

"The CreateTourPromotionFieldsInput input type is used in operations that involve creation of objects in the TourPromotion class."
input CreateTourPromotionFieldsInput {
    ACL: ACLInput
    "This is the object promoId."
    promoId: PromotionRelationInput
    "This is the object tourId."
    tourId: TourRelationInput
}

input CreateTourPromotionInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateTourPromotionFieldsInput
}

"The CreateToursInPackFieldsInput input type is used in operations that involve creation of objects in the ToursInPack class."
input CreateToursInPackFieldsInput {
    ACL: ACLInput
    "This is the object packId."
    packId: PackRelationInput
    "This is the object tourId."
    tourId: TourRelationInput
}

input CreateToursInPackInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateToursInPackFieldsInput
}

"The CreateUserFieldsInput input type is used in operations that involve creation of objects in the User class."
input CreateUserFieldsInput {
    ACL: ACLInput
    "This is the object authData."
    authData: Object
    "This is the object email."
    email: String
    "This is the object emailVerified."
    emailVerified: Boolean
    "This is the object password."
    password: String!
    "This is the object username."
    username: String!
}

input CreateUserInput {
    clientMutationId: String
    "These are the fields that will be used to create the new object."
    fields: CreateUserFieldsInput
}

"The DateWhereInput input type is used in operations that involve filtering objects by a field of type Date."
input DateWhereInput {
    "This is the equalTo operator to specify a constraint to select the objects where the value of a field equals to a specified value."
    equalTo: Date
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the greaterThan operator to specify a constraint to select the objects where the value of a field is greater than a specified value."
    greaterThan: Date
    "This is the greaterThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is greater than or equal to a specified value."
    greaterThanOrEqualTo: Date
    "This is the in operator to specify a constraint to select the objects where the value of a field equals any value in the specified array."
    in: [Date]
    "This is the inQueryKey operator to specify a constraint to select the objects where a field equals to a key in the result of a different query."
    inQueryKey: SelectInput
    "This is the lessThan operator to specify a constraint to select the objects where the value of a field is less than a specified value."
    lessThan: Date
    "This is the lessThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is less than or equal to a specified value."
    lessThanOrEqualTo: Date
    "This is the notEqualTo operator to specify a constraint to select the objects where the value of a field do not equal to a specified value."
    notEqualTo: Date
    "This is the notIn operator to specify a constraint to select the objects where the value of a field do not equal any value in the specified array."
    notIn: [Date]
    "This is the notInQueryKey operator to specify a constraint to select the objects where a field do not equal to a key in the result of a different query."
    notInQueryKey: SelectInput
}

input DeleteB4aCustomFieldInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteB4aMenuItemInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteB4aSettingInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteCategoryInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteClassInput {
    clientMutationId: String
    "This is the name of the object class."
    name: String!
}

input DeleteMyClassInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeletePackInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeletePackPromotionInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeletePlaceInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeletePromotionInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteRoleInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteSessionInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteStateInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteTourCategoryInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteTourImageInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteTourInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteTourPlaceInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteTourPromotionInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteToursInPackInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input DeleteUserInput {
    clientMutationId: String
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input FileInput {
    "A File Scalar can be an url or a FileInfo object. If this field is set to null the file will be unlinked."
    file: File
    "Use this field if you want to unlink the file (the file will not be deleted on cloud storage)"
    unlink: Boolean
    "Use this field if you want to create a new file."
    upload: Upload
}

"The FileWhereInput input type is used in operations that involve filtering objects by a field of type File."
input FileWhereInput {
    "This is the equalTo operator to specify a constraint to select the objects where the value of a field equals to a specified value."
    equalTo: File
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the greaterThan operator to specify a constraint to select the objects where the value of a field is greater than a specified value."
    greaterThan: File
    "This is the greaterThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is greater than or equal to a specified value."
    greaterThanOrEqualTo: File
    "This is the in operator to specify a constraint to select the objects where the value of a field equals any value in the specified array."
    in: [File]
    "This is the inQueryKey operator to specify a constraint to select the objects where a field equals to a key in the result of a different query."
    inQueryKey: SelectInput
    "This is the lessThan operator to specify a constraint to select the objects where the value of a field is less than a specified value."
    lessThan: File
    "This is the lessThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is less than or equal to a specified value."
    lessThanOrEqualTo: File
    "This is the matchesRegex operator to specify a constraint to select the objects where the value of a field matches a specified regular expression."
    matchesRegex: String
    "This is the notEqualTo operator to specify a constraint to select the objects where the value of a field do not equal to a specified value."
    notEqualTo: File
    "This is the notIn operator to specify a constraint to select the objects where the value of a field do not equal any value in the specified array."
    notIn: [File]
    "This is the notInQueryKey operator to specify a constraint to select the objects where a field do not equal to a key in the result of a different query."
    notInQueryKey: SelectInput
    "This is the options operator to specify optional flags (such as \"i\" and \"m\") to be added to a matchesRegex operation in the same set of constraints."
    options: String
}

"The GeoIntersectsInput type is used to specify a geoIntersects operation on a constraint."
input GeoIntersectsInput {
    "This is the point to be specified."
    point: GeoPointInput
}

"The GeoPointInput type is used in operations that involve inputting fields of type geo point."
input GeoPointInput {
    "This is the latitude."
    latitude: Float!
    "This is the longitude."
    longitude: Float!
}

"The GeoPointWhereInput input type is used in operations that involve filtering objects by a field of type GeoPoint."
input GeoPointWhereInput {
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the geoWithin operator to specify a constraint to select the objects where the values of a geo point field is within a specified polygon or sphere."
    geoWithin: GeoWithinInput
    "This is the maxDistance operator to specify a constraint to select the objects where the values of a geo point field is at a max distance (in radians) from the geo point specified in the $nearSphere operator."
    maxDistance: Float
    "This is the maxDistanceInKilometers operator to specify a constraint to select the objects where the values of a geo point field is at a max distance (in kilometers) from the geo point specified in the $nearSphere operator."
    maxDistanceInKilometers: Float
    "This is the maxDistanceInMiles operator to specify a constraint to select the objects where the values of a geo point field is at a max distance (in miles) from the geo point specified in the $nearSphere operator."
    maxDistanceInMiles: Float
    "This is the maxDistanceInRadians operator to specify a constraint to select the objects where the values of a geo point field is at a max distance (in radians) from the geo point specified in the $nearSphere operator."
    maxDistanceInRadians: Float
    "This is the nearSphere operator to specify a constraint to select the objects where the values of a geo point field is near to another geo point."
    nearSphere: GeoPointInput
    "This is the within operator to specify a constraint to select the objects where the values of a geo point field is within a specified box."
    within: WithinInput
}

"The GeoWithinInput type is used to specify a geoWithin operation on a constraint."
input GeoWithinInput {
    "This is the sphere to be specified."
    centerSphere: CenterSphereInput
    "This is the polygon to be specified."
    polygon: [GeoPointInput!]
}

"The IdWhereInput input type is used in operations that involve filtering objects by an id."
input IdWhereInput {
    "This is the equalTo operator to specify a constraint to select the objects where the value of a field equals to a specified value."
    equalTo: ID
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the greaterThan operator to specify a constraint to select the objects where the value of a field is greater than a specified value."
    greaterThan: ID
    "This is the greaterThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is greater than or equal to a specified value."
    greaterThanOrEqualTo: ID
    "This is the in operator to specify a constraint to select the objects where the value of a field equals any value in the specified array."
    in: [ID]
    "This is the inQueryKey operator to specify a constraint to select the objects where a field equals to a key in the result of a different query."
    inQueryKey: SelectInput
    "This is the lessThan operator to specify a constraint to select the objects where the value of a field is less than a specified value."
    lessThan: ID
    "This is the lessThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is less than or equal to a specified value."
    lessThanOrEqualTo: ID
    "This is the notEqualTo operator to specify a constraint to select the objects where the value of a field do not equal to a specified value."
    notEqualTo: ID
    "This is the notIn operator to specify a constraint to select the objects where the value of a field do not equal any value in the specified array."
    notIn: [ID]
    "This is the notInQueryKey operator to specify a constraint to select the objects where a field do not equal to a key in the result of a different query."
    notInQueryKey: SelectInput
}

"An entry from an object, i.e., a pair of key and value."
input KeyValueInput {
    "The key used to retrieve the value of this entry."
    key: String!
    "The value of the entry. Could be any type of scalar data."
    value: Any!
}

input LogInInput {
    clientMutationId: String
    "This is the password used to log in the user."
    password: String!
    "This is the username used to log in the user."
    username: String!
}

input LogInWithInput {
    authData: Object!
    clientMutationId: String
    fields: UserLoginWithInput
}

input LogOutInput {
    clientMutationId: String
}

"Allow to link OR add and link an object of the MyClass class."
input MyClassPointerInput {
    "Create and link an object from MyClass class."
    createAndLink: CreateMyClassFieldsInput
    "Link an existing object from MyClass class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the MyClass class into a relation field."
input MyClassRelationInput {
    "Add existing objects from the MyClass class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the MyClass class into the relation."
    createAndAdd: [CreateMyClassFieldsInput!]
    "Remove existing objects from the MyClass class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The MyClassRelationWhereInput input type is used in operations that involve filtering objects of MyClass class."
input MyClassRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: MyClassWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: MyClassWhereInput
}

"The MyClassWhereInput input type is used in operations that involve filtering objects of MyClass class."
input MyClassWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [MyClassWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [MyClassWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [MyClassWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object myField."
    myField: StringWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"The NumberWhereInput input type is used in operations that involve filtering objects by a field of type Number."
input NumberWhereInput {
    "This is the equalTo operator to specify a constraint to select the objects where the value of a field equals to a specified value."
    equalTo: Float
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the greaterThan operator to specify a constraint to select the objects where the value of a field is greater than a specified value."
    greaterThan: Float
    "This is the greaterThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is greater than or equal to a specified value."
    greaterThanOrEqualTo: Float
    "This is the in operator to specify a constraint to select the objects where the value of a field equals any value in the specified array."
    in: [Float]
    "This is the inQueryKey operator to specify a constraint to select the objects where a field equals to a key in the result of a different query."
    inQueryKey: SelectInput
    "This is the lessThan operator to specify a constraint to select the objects where the value of a field is less than a specified value."
    lessThan: Float
    "This is the lessThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is less than or equal to a specified value."
    lessThanOrEqualTo: Float
    "This is the notEqualTo operator to specify a constraint to select the objects where the value of a field do not equal to a specified value."
    notEqualTo: Float
    "This is the notIn operator to specify a constraint to select the objects where the value of a field do not equal any value in the specified array."
    notIn: [Float]
    "This is the notInQueryKey operator to specify a constraint to select the objects where a field do not equal to a key in the result of a different query."
    notInQueryKey: SelectInput
}

"The ObjectWhereInput input type is used in operations that involve filtering result by a field of type Object."
input ObjectWhereInput {
    "This is the equalTo operator to specify a constraint to select the objects where the value of a field equals to a specified value."
    equalTo: KeyValueInput
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the greaterThan operator to specify a constraint to select the objects where the value of a field is greater than a specified value."
    greaterThan: KeyValueInput
    "This is the greaterThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is greater than or equal to a specified value."
    greaterThanOrEqualTo: KeyValueInput
    "This is the in operator to specify a constraint to select the objects where the value of a field equals any value in the specified array."
    in: [KeyValueInput]
    "This is the inQueryKey operator to specify a constraint to select the objects where a field equals to a key in the result of a different query."
    inQueryKey: SelectInput
    "This is the lessThan operator to specify a constraint to select the objects where the value of a field is less than a specified value."
    lessThan: KeyValueInput
    "This is the lessThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is less than or equal to a specified value."
    lessThanOrEqualTo: KeyValueInput
    "This is the notEqualTo operator to specify a constraint to select the objects where the value of a field do not equal to a specified value."
    notEqualTo: KeyValueInput
    "This is the notIn operator to specify a constraint to select the objects where the value of a field do not equal any value in the specified array."
    notIn: [KeyValueInput]
    "This is the notInQueryKey operator to specify a constraint to select the objects where a field do not equal to a key in the result of a different query."
    notInQueryKey: SelectInput
}

"Allow to link OR add and link an object of the Pack class."
input PackPointerInput {
    "Create and link an object from Pack class."
    createAndLink: CreatePackFieldsInput
    "Link an existing object from Pack class. You can use either the global or the object id."
    link: ID
}

"Allow to link OR add and link an object of the PackPromotion class."
input PackPromotionPointerInput {
    "Create and link an object from PackPromotion class."
    createAndLink: CreatePackPromotionFieldsInput
    "Link an existing object from PackPromotion class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the PackPromotion class into a relation field."
input PackPromotionRelationInput {
    "Add existing objects from the PackPromotion class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the PackPromotion class into the relation."
    createAndAdd: [CreatePackPromotionFieldsInput!]
    "Remove existing objects from the PackPromotion class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The PackPromotionRelationWhereInput input type is used in operations that involve filtering objects of PackPromotion class."
input PackPromotionRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: PackPromotionWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: PackPromotionWhereInput
}

"The PackPromotionWhereInput input type is used in operations that involve filtering objects of PackPromotion class."
input PackPromotionWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [PackPromotionWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [PackPromotionWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [PackPromotionWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object packId."
    packId: PackRelationWhereInput
    "This is the object promoId."
    promoId: UserRelationWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to add, remove, createAndAdd objects of the Pack class into a relation field."
input PackRelationInput {
    "Add existing objects from the Pack class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the Pack class into the relation."
    createAndAdd: [CreatePackFieldsInput!]
    "Remove existing objects from the Pack class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The PackRelationWhereInput input type is used in operations that involve filtering objects of Pack class."
input PackRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: PackWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: PackWhereInput
}

"The PackWhereInput input type is used in operations that involve filtering objects of Pack class."
input PackWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [PackWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [PackWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [PackWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object packDescription."
    packDescription: StringWhereInput
    "This is the object packFeaturesExcluded."
    packFeaturesExcluded: StringWhereInput
    "This is the object packFeaturesIncluded."
    packFeaturesIncluded: StringWhereInput
    "This is the object packImg."
    packImg: FileWhereInput
    "This is the object packIsActive."
    packIsActive: BooleanWhereInput
    "This is the object packName."
    packName: StringWhereInput
    "This is the object packPrice."
    packPrice: StringWhereInput
    "This is the object packShortDescription."
    packShortDescription: StringWhereInput
    "This is the object packThumb."
    packThumb: FileWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to link OR add and link an object of the Place class."
input PlacePointerInput {
    "Create and link an object from Place class."
    createAndLink: CreatePlaceFieldsInput
    "Link an existing object from Place class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the Place class into a relation field."
input PlaceRelationInput {
    "Add existing objects from the Place class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the Place class into the relation."
    createAndAdd: [CreatePlaceFieldsInput!]
    "Remove existing objects from the Place class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The PlaceRelationWhereInput input type is used in operations that involve filtering objects of Place class."
input PlaceRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: PlaceWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: PlaceWhereInput
}

"The PlaceWhereInput input type is used in operations that involve filtering objects of Place class."
input PlaceWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [PlaceWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [PlaceWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [PlaceWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object placeDescription."
    placeDescription: StringWhereInput
    "This is the object placeImg."
    placeImg: FileWhereInput
    "This is the object placeName."
    placeName: StringWhereInput
    "This is the object placeShortDescription."
    placeShortDescription: StringWhereInput
    "This is the object placeThumb."
    placeThumb: FileWhereInput
    "This is the object stateId."
    stateId: StateRelationWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"The PointerFieldInput is used to specify a field of type pointer for an object class schema."
input PointerFieldInput {
    "This is the field name."
    name: String!
    "This is the name of the target class for the field."
    targetClassName: String!
}

"The PolygonWhereInput input type is used in operations that involve filtering objects by a field of type Polygon."
input PolygonWhereInput {
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the geoIntersects operator to specify a constraint to select the objects where the values of a polygon field intersect a specified point."
    geoIntersects: GeoIntersectsInput
}

"Allow to link OR add and link an object of the Promotion class."
input PromotionPointerInput {
    "Create and link an object from Promotion class."
    createAndLink: CreatePromotionFieldsInput
    "Link an existing object from Promotion class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the Promotion class into a relation field."
input PromotionRelationInput {
    "Add existing objects from the Promotion class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the Promotion class into the relation."
    createAndAdd: [CreatePromotionFieldsInput!]
    "Remove existing objects from the Promotion class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The PromotionRelationWhereInput input type is used in operations that involve filtering objects of Promotion class."
input PromotionRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: PromotionWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: PromotionWhereInput
}

"The PromotionWhereInput input type is used in operations that involve filtering objects of Promotion class."
input PromotionWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [PromotionWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [PromotionWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [PromotionWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object promoDescription."
    promoDescription: StringWhereInput
    "This is the object promoFeaturesExcluded."
    promoFeaturesExcluded: StringWhereInput
    "This is the object promoFeaturesIncluded."
    promoFeaturesIncluded: StringWhereInput
    "This is the object promoImg."
    promoImg: FileWhereInput
    "This is the object promoName."
    promoName: StringWhereInput
    "This is the object promoPrice."
    promoPrice: StringWhereInput
    "This is the object promoThumb."
    promoThumb: FileWhereInput
    "This is the object promoValidFrom."
    promoValidFrom: DateWhereInput
    "This is the object promoValidUntil."
    promoValidUntil: DateWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to manage public rights."
input PublicACLInput {
    "Allow anyone to read the current object."
    read: Boolean!
    "Allow anyone to write on the current object."
    write: Boolean!
}

"The ReadOptionsInputt type is used in queries in order to set the read preferences."
input ReadOptionsInput {
    "The read preference for the queries to be executed to include fields."
    includeReadPreference: ReadPreference
    "The read preference for the main query to be executed."
    readPreference: ReadPreference
    "The read preference for the subqueries that may be required."
    subqueryReadPreference: ReadPreference
}

"The RelationFieldInput is used to specify a field of type relation for an object class schema."
input RelationFieldInput {
    "This is the field name."
    name: String!
    "This is the name of the target class for the field."
    targetClassName: String!
}

input ResetPasswordInput {
    clientMutationId: String
    email: String!
}

"Allow to manage roles in ACL."
input RoleACLInput {
    "Allow users who are members of the role to read the current object."
    read: Boolean!
    "Name of the targetted Role."
    roleName: String!
    "Allow users who are members of the role to write on the current object."
    write: Boolean!
}

"Allow to link OR add and link an object of the Role class."
input RolePointerInput {
    "Create and link an object from Role class."
    createAndLink: CreateRoleFieldsInput
    "Link an existing object from Role class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the Role class into a relation field."
input RoleRelationInput {
    "Add existing objects from the Role class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the Role class into the relation."
    createAndAdd: [CreateRoleFieldsInput!]
    "Remove existing objects from the Role class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The RoleRelationWhereInput input type is used in operations that involve filtering objects of Role class."
input RoleRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: RoleWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: RoleWhereInput
}

"The RoleWhereInput input type is used in operations that involve filtering objects of Role class."
input RoleWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [RoleWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [RoleWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [RoleWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object name."
    name: StringWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object roles."
    roles: RoleRelationWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
    "This is the object users."
    users: UserRelationWhereInput
}

"The SchemaArrayFieldInput is used to specify a field of type array for an object class schema."
input SchemaArrayFieldInput {
    "This is the field name."
    name: String!
}

"The SchemaBooleanFieldInput is used to specify a field of type boolean for an object class schema."
input SchemaBooleanFieldInput {
    "This is the field name."
    name: String!
}

"The SchemaBytesFieldInput is used to specify a field of type bytes for an object class schema."
input SchemaBytesFieldInput {
    "This is the field name."
    name: String!
}

"The SchemaDateFieldInput is used to specify a field of type date for an object class schema."
input SchemaDateFieldInput {
    "This is the field name."
    name: String!
}

"The SchemaFieldInput is used to specify a field of an object class schema."
input SchemaFieldInput {
    "This is the field name."
    name: String!
}

"The CreateClassSchemaInput type is used to specify the schema for a new object class to be created."
input SchemaFieldsInput {
    "These are the Array fields to be added to the class schema."
    addArrays: [SchemaArrayFieldInput!]
    "These are the Boolean fields to be added to the class schema."
    addBooleans: [SchemaBooleanFieldInput!]
    "These are the Bytes fields to be added to the class schema."
    addBytes: [SchemaBytesFieldInput!]
    "These are the Date fields to be added to the class schema."
    addDates: [SchemaDateFieldInput!]
    "These are the File fields to be added to the class schema."
    addFiles: [SchemaFileFieldInput!]
    "This is the Geo Point field to be added to the class schema. Currently it is supported only one GeoPoint field per Class."
    addGeoPoint: SchemaGeoPointFieldInput
    "These are the Number fields to be added to the class schema."
    addNumbers: [SchemaNumberFieldInput!]
    "These are the Object fields to be added to the class schema."
    addObjects: [SchemaObjectFieldInput!]
    "These are the Pointer fields to be added to the class schema."
    addPointers: [PointerFieldInput!]
    "These are the Polygon fields to be added to the class schema."
    addPolygons: [SchemaPolygonFieldInput!]
    "These are the Relation fields to be added to the class schema."
    addRelations: [RelationFieldInput!]
    "These are the String fields to be added to the class schema."
    addStrings: [SchemaStringFieldInput!]
    "These are the fields to be removed from the class schema."
    remove: [SchemaFieldInput!]
}

"The SchemaFileFieldInput is used to specify a field of type file for an object class schema."
input SchemaFileFieldInput {
    "This is the field name."
    name: String!
}

"The SchemaGeoPointFieldInput is used to specify a field of type geo point for an object class schema."
input SchemaGeoPointFieldInput {
    "This is the field name."
    name: String!
}

"The SchemaNumberFieldInput is used to specify a field of type number for an object class schema."
input SchemaNumberFieldInput {
    "This is the field name."
    name: String!
}

"The SchemaObjectFieldInput is used to specify a field of type object for an object class schema."
input SchemaObjectFieldInput {
    "This is the field name."
    name: String!
}

"The SchemaPolygonFieldInput is used to specify a field of type polygon for an object class schema."
input SchemaPolygonFieldInput {
    "This is the field name."
    name: String!
}

"The SchemaStringFieldInput is used to specify a field of type string for an object class schema."
input SchemaStringFieldInput {
    "This is the field name."
    name: String!
}

"The SearchInput type is used to specifiy a search operation on a full text search."
input SearchInput {
    "This is the flag to enable or disable case sensitive search."
    caseSensitive: Boolean
    "This is the flag to enable or disable diacritic sensitive search."
    diacriticSensitive: Boolean
    "This is the language to tetermine the list of stop words and the rules for tokenizer."
    language: String
    "This is the term to be searched."
    term: String!
}

"The SelectInput type is used to specify an inQueryKey or a notInQueryKey operation on a constraint."
input SelectInput {
    "This is the key in the result of the subquery that must match (not match) the field."
    key: String!
    "This is the subquery to be executed."
    query: SubqueryInput!
}

input SendVerificationEmailInput {
    clientMutationId: String
    email: String!
}

"Allow to link OR add and link an object of the Session class."
input SessionPointerInput {
    "Create and link an object from Session class."
    createAndLink: CreateSessionFieldsInput
    "Link an existing object from Session class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the Session class into a relation field."
input SessionRelationInput {
    "Add existing objects from the Session class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the Session class into the relation."
    createAndAdd: [CreateSessionFieldsInput!]
    "Remove existing objects from the Session class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The SessionRelationWhereInput input type is used in operations that involve filtering objects of Session class."
input SessionRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: SessionWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: SessionWhereInput
}

"The SessionWhereInput input type is used in operations that involve filtering objects of Session class."
input SessionWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [SessionWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [SessionWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [SessionWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object createdWith."
    createdWith: ObjectWhereInput
    "This is the object expiresAt."
    expiresAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object installationId."
    installationId: StringWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object restricted."
    restricted: BooleanWhereInput
    "This is the object sessionToken."
    sessionToken: StringWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
    "This is the object user."
    user: UserRelationWhereInput
}

input SignUpInput {
    clientMutationId: String
    fields: CreateUserFieldsInput
}

"Allow to link OR add and link an object of the State class."
input StatePointerInput {
    "Create and link an object from State class."
    createAndLink: CreateStateFieldsInput
    "Link an existing object from State class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the State class into a relation field."
input StateRelationInput {
    "Add existing objects from the State class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the State class into the relation."
    createAndAdd: [CreateStateFieldsInput!]
    "Remove existing objects from the State class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The StateRelationWhereInput input type is used in operations that involve filtering objects of State class."
input StateRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: StateWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: StateWhereInput
}

"The StateWhereInput input type is used in operations that involve filtering objects of State class."
input StateWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [StateWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [StateWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [StateWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object stateAbbr."
    stateAbbr: StringWhereInput
    "This is the object stateImg."
    stateImg: FileWhereInput
    "This is the object stateName."
    stateName: StringWhereInput
    "This is the object stateThumb."
    stateThumb: FileWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"The StringWhereInput input type is used in operations that involve filtering objects by a field of type String."
input StringWhereInput {
    "This is the equalTo operator to specify a constraint to select the objects where the value of a field equals to a specified value."
    equalTo: String
    "This is the exists operator to specify a constraint to select the objects where a field exists (or do not exist)."
    exists: Boolean
    "This is the greaterThan operator to specify a constraint to select the objects where the value of a field is greater than a specified value."
    greaterThan: String
    "This is the greaterThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is greater than or equal to a specified value."
    greaterThanOrEqualTo: String
    "This is the in operator to specify a constraint to select the objects where the value of a field equals any value in the specified array."
    in: [String]
    "This is the inQueryKey operator to specify a constraint to select the objects where a field equals to a key in the result of a different query."
    inQueryKey: SelectInput
    "This is the lessThan operator to specify a constraint to select the objects where the value of a field is less than a specified value."
    lessThan: String
    "This is the lessThanOrEqualTo operator to specify a constraint to select the objects where the value of a field is less than or equal to a specified value."
    lessThanOrEqualTo: String
    "This is the matchesRegex operator to specify a constraint to select the objects where the value of a field matches a specified regular expression."
    matchesRegex: String
    "This is the notEqualTo operator to specify a constraint to select the objects where the value of a field do not equal to a specified value."
    notEqualTo: String
    "This is the notIn operator to specify a constraint to select the objects where the value of a field do not equal any value in the specified array."
    notIn: [String]
    "This is the notInQueryKey operator to specify a constraint to select the objects where a field do not equal to a key in the result of a different query."
    notInQueryKey: SelectInput
    "This is the options operator to specify optional flags (such as \"i\" and \"m\") to be added to a matchesRegex operation in the same set of constraints."
    options: String
    "This is the $text operator to specify a full text search constraint."
    text: TextInput
}

"The SubqueryInput type is used to specify a sub query to another class."
input SubqueryInput {
    "This is the class name of the object."
    className: String!
    "These are the conditions that the objects need to match in order to be found"
    where: Object!
}

"The TextInput type is used to specify a text operation on a constraint."
input TextInput {
    "This is the search to be executed."
    search: SearchInput!
}

"Allow to link OR add and link an object of the TourCategory class."
input TourCategoryPointerInput {
    "Create and link an object from TourCategory class."
    createAndLink: CreateTourCategoryFieldsInput
    "Link an existing object from TourCategory class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the TourCategory class into a relation field."
input TourCategoryRelationInput {
    "Add existing objects from the TourCategory class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the TourCategory class into the relation."
    createAndAdd: [CreateTourCategoryFieldsInput!]
    "Remove existing objects from the TourCategory class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The TourCategoryRelationWhereInput input type is used in operations that involve filtering objects of TourCategory class."
input TourCategoryRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: TourCategoryWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: TourCategoryWhereInput
}

"The TourCategoryWhereInput input type is used in operations that involve filtering objects of TourCategory class."
input TourCategoryWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [TourCategoryWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [TourCategoryWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [TourCategoryWhereInput!]
    "This is the object categoryId."
    categoryId: CategoryRelationWhereInput
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object tourId."
    tourId: TourRelationWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to link OR add and link an object of the TourImage class."
input TourImagePointerInput {
    "Create and link an object from TourImage class."
    createAndLink: CreateTourImageFieldsInput
    "Link an existing object from TourImage class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the TourImage class into a relation field."
input TourImageRelationInput {
    "Add existing objects from the TourImage class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the TourImage class into the relation."
    createAndAdd: [CreateTourImageFieldsInput!]
    "Remove existing objects from the TourImage class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The TourImageRelationWhereInput input type is used in operations that involve filtering objects of TourImage class."
input TourImageRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: TourImageWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: TourImageWhereInput
}

"The TourImageWhereInput input type is used in operations that involve filtering objects of TourImage class."
input TourImageWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [TourImageWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [TourImageWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [TourImageWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object tourId."
    tourId: TourRelationWhereInput
    "This is the object tourImg."
    tourImg: FileWhereInput
    "This is the object tourThumb."
    tourThumb: FileWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to link OR add and link an object of the TourPlace class."
input TourPlacePointerInput {
    "Create and link an object from TourPlace class."
    createAndLink: CreateTourPlaceFieldsInput
    "Link an existing object from TourPlace class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the TourPlace class into a relation field."
input TourPlaceRelationInput {
    "Add existing objects from the TourPlace class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the TourPlace class into the relation."
    createAndAdd: [CreateTourPlaceFieldsInput!]
    "Remove existing objects from the TourPlace class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The TourPlaceRelationWhereInput input type is used in operations that involve filtering objects of TourPlace class."
input TourPlaceRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: TourPlaceWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: TourPlaceWhereInput
}

"The TourPlaceWhereInput input type is used in operations that involve filtering objects of TourPlace class."
input TourPlaceWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [TourPlaceWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [TourPlaceWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [TourPlaceWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object placeId."
    placeId: PlaceRelationWhereInput
    "This is the object tourId."
    tourId: TourRelationWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to link OR add and link an object of the Tour class."
input TourPointerInput {
    "Create and link an object from Tour class."
    createAndLink: CreateTourFieldsInput
    "Link an existing object from Tour class. You can use either the global or the object id."
    link: ID
}

"Allow to link OR add and link an object of the TourPromotion class."
input TourPromotionPointerInput {
    "Create and link an object from TourPromotion class."
    createAndLink: CreateTourPromotionFieldsInput
    "Link an existing object from TourPromotion class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the TourPromotion class into a relation field."
input TourPromotionRelationInput {
    "Add existing objects from the TourPromotion class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the TourPromotion class into the relation."
    createAndAdd: [CreateTourPromotionFieldsInput!]
    "Remove existing objects from the TourPromotion class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The TourPromotionRelationWhereInput input type is used in operations that involve filtering objects of TourPromotion class."
input TourPromotionRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: TourPromotionWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: TourPromotionWhereInput
}

"The TourPromotionWhereInput input type is used in operations that involve filtering objects of TourPromotion class."
input TourPromotionWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [TourPromotionWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [TourPromotionWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [TourPromotionWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object promoId."
    promoId: PromotionRelationWhereInput
    "This is the object tourId."
    tourId: TourRelationWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to add, remove, createAndAdd objects of the Tour class into a relation field."
input TourRelationInput {
    "Add existing objects from the Tour class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the Tour class into the relation."
    createAndAdd: [CreateTourFieldsInput!]
    "Remove existing objects from the Tour class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The TourRelationWhereInput input type is used in operations that involve filtering objects of Tour class."
input TourRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: TourWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: TourWhereInput
}

"The TourWhereInput input type is used in operations that involve filtering objects of Tour class."
input TourWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [TourWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [TourWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [TourWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object tourDescription."
    tourDescription: StringWhereInput
    "This is the object tourFeaturesExcluded."
    tourFeaturesExcluded: StringWhereInput
    "This is the object tourFeaturesIncluded."
    tourFeaturesIncluded: StringWhereInput
    "This is the object tourIsActive."
    tourIsActive: BooleanWhereInput
    "This is the object tourName."
    tourName: StringWhereInput
    "This is the object tourPrice."
    tourPrice: StringWhereInput
    "This is the object tourShortDescription."
    tourShortDescription: StringWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"Allow to link OR add and link an object of the ToursInPack class."
input ToursInPackPointerInput {
    "Create and link an object from ToursInPack class."
    createAndLink: CreateToursInPackFieldsInput
    "Link an existing object from ToursInPack class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the ToursInPack class into a relation field."
input ToursInPackRelationInput {
    "Add existing objects from the ToursInPack class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the ToursInPack class into the relation."
    createAndAdd: [CreateToursInPackFieldsInput!]
    "Remove existing objects from the ToursInPack class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The ToursInPackRelationWhereInput input type is used in operations that involve filtering objects of ToursInPack class."
input ToursInPackRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: ToursInPackWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: ToursInPackWhereInput
}

"The ToursInPackWhereInput input type is used in operations that involve filtering objects of ToursInPack class."
input ToursInPackWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [ToursInPackWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [ToursInPackWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [ToursInPackWhereInput!]
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object packId."
    packId: PackRelationWhereInput
    "This is the object tourId."
    tourId: TourRelationWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
}

"The UpdateB4aCustomFieldFieldsInput input type is used in operations that involve creation of objects in the B4aCustomField class."
input UpdateB4aCustomFieldFieldsInput {
    ACL: ACLInput
    "This is the object cssClassName."
    cssClassName: String
    "This is the object defaultValue."
    defaultValue: String
    "This is the object inputMask."
    inputMask: String
    "This is the object isFormHidden."
    isFormHidden: String
    "This is the object isRequired."
    isRequired: Boolean
    "This is the object isTableHidden."
    isTableHidden: Boolean
    "This is the object objectClassFieldName."
    objectClassFieldName: String
    "This is the object objectClassName."
    objectClassName: String
    "This is the object options."
    options: String
    "This is the object referenceTitleField."
    referenceTitleField: String
    "This is the object referencesLinkText."
    referencesLinkText: String
    "This is the object referencesLinkTitle."
    referencesLinkTitle: String
    "This is the object relevance."
    relevance: Float
    "This is the object subType."
    subType: String
    "This is the object title."
    title: String
}

input UpdateB4aCustomFieldInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateB4aCustomFieldFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateB4aMenuItemFieldsInput input type is used in operations that involve creation of objects in the B4aMenuItem class."
input UpdateB4aMenuItemFieldsInput {
    ACL: ACLInput
    "This is the object addFormTitle."
    addFormTitle: String
    "This is the object editFormTitle."
    editFormTitle: String
    "This is the object isHidden."
    isHidden: Boolean
    "This is the object isReadOnly."
    isReadOnly: Boolean
    "This is the object objectClassName."
    objectClassName: String
    "This is the object relevance."
    relevance: String
    "This is the object title."
    title: String
}

input UpdateB4aMenuItemInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateB4aMenuItemFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateB4aSettingFieldsInput input type is used in operations that involve creation of objects in the B4aSetting class."
input UpdateB4aSettingFieldsInput {
    ACL: ACLInput
    "This is the object key."
    key: String
    "This is the object value."
    value: String
}

input UpdateB4aSettingInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateB4aSettingFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateCategoryFieldsInput input type is used in operations that involve creation of objects in the Category class."
input UpdateCategoryFieldsInput {
    ACL: ACLInput
    "This is the object categoryIcon."
    categoryIcon: String
    "This is the object categoryIconType."
    categoryIconType: Float
    "This is the object categoryImg."
    categoryImg: FileInput
    "This is the object categoryName."
    categoryName: String
    "This is the object categoryThumb."
    categoryThumb: FileInput
}

input UpdateCategoryInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateCategoryFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input UpdateClassInput {
    clientMutationId: String
    "This is the name of the object class."
    name: String!
    "These are the schema's fields of the object class."
    schemaFields: SchemaFieldsInput
}

"The UpdateMyClassFieldsInput input type is used in operations that involve creation of objects in the MyClass class."
input UpdateMyClassFieldsInput {
    ACL: ACLInput
    "This is the object myField."
    myField: String
}

input UpdateMyClassInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateMyClassFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdatePackFieldsInput input type is used in operations that involve creation of objects in the Pack class."
input UpdatePackFieldsInput {
    ACL: ACLInput
    "This is the object packDescription."
    packDescription: String
    "This is the object packFeaturesExcluded."
    packFeaturesExcluded: String
    "This is the object packFeaturesIncluded."
    packFeaturesIncluded: String
    "This is the object packImg."
    packImg: FileInput
    "This is the object packIsActive."
    packIsActive: Boolean
    "This is the object packName."
    packName: String
    "This is the object packPrice."
    packPrice: String
    "This is the object packShortDescription."
    packShortDescription: String
    "This is the object packThumb."
    packThumb: FileInput
}

input UpdatePackInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdatePackFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdatePackPromotionFieldsInput input type is used in operations that involve creation of objects in the PackPromotion class."
input UpdatePackPromotionFieldsInput {
    ACL: ACLInput
    "This is the object packId."
    packId: PackRelationInput
    "This is the object promoId."
    promoId: UserRelationInput
}

input UpdatePackPromotionInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdatePackPromotionFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdatePlaceFieldsInput input type is used in operations that involve creation of objects in the Place class."
input UpdatePlaceFieldsInput {
    ACL: ACLInput
    "This is the object placeDescription."
    placeDescription: String
    "This is the object placeImg."
    placeImg: FileInput
    "This is the object placeName."
    placeName: String
    "This is the object placeShortDescription."
    placeShortDescription: String
    "This is the object placeThumb."
    placeThumb: FileInput
    "This is the object stateId."
    stateId: StateRelationInput
}

input UpdatePlaceInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdatePlaceFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdatePromotionFieldsInput input type is used in operations that involve creation of objects in the Promotion class."
input UpdatePromotionFieldsInput {
    ACL: ACLInput
    "This is the object promoDescription."
    promoDescription: String
    "This is the object promoFeaturesExcluded."
    promoFeaturesExcluded: String
    "This is the object promoFeaturesIncluded."
    promoFeaturesIncluded: String
    "This is the object promoImg."
    promoImg: FileInput
    "This is the object promoName."
    promoName: String
    "This is the object promoPrice."
    promoPrice: String
    "This is the object promoThumb."
    promoThumb: FileInput
    "This is the object promoValidFrom."
    promoValidFrom: Date
    "This is the object promoValidUntil."
    promoValidUntil: Date
}

input UpdatePromotionInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdatePromotionFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateRoleFieldsInput input type is used in operations that involve creation of objects in the Role class."
input UpdateRoleFieldsInput {
    ACL: ACLInput
    "This is the object name."
    name: String
    "This is the object roles."
    roles: RoleRelationInput
    "This is the object users."
    users: UserRelationInput
}

input UpdateRoleInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateRoleFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateSessionFieldsInput input type is used in operations that involve creation of objects in the Session class."
input UpdateSessionFieldsInput {
    ACL: ACLInput
    "This is the object createdWith."
    createdWith: Object
    "This is the object expiresAt."
    expiresAt: Date
    "This is the object installationId."
    installationId: String
    "This is the object restricted."
    restricted: Boolean
    "This is the object sessionToken."
    sessionToken: String
    "This is the object user."
    user: UserPointerInput
}

input UpdateSessionInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateSessionFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateStateFieldsInput input type is used in operations that involve creation of objects in the State class."
input UpdateStateFieldsInput {
    ACL: ACLInput
    "This is the object stateAbbr."
    stateAbbr: String
    "This is the object stateImg."
    stateImg: FileInput
    "This is the object stateName."
    stateName: String
    "This is the object stateThumb."
    stateThumb: FileInput
}

input UpdateStateInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateStateFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateTourCategoryFieldsInput input type is used in operations that involve creation of objects in the TourCategory class."
input UpdateTourCategoryFieldsInput {
    ACL: ACLInput
    "This is the object categoryId."
    categoryId: CategoryRelationInput
    "This is the object tourId."
    tourId: TourRelationInput
}

input UpdateTourCategoryInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateTourCategoryFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateTourFieldsInput input type is used in operations that involve creation of objects in the Tour class."
input UpdateTourFieldsInput {
    ACL: ACLInput
    "This is the object tourDescription."
    tourDescription: String
    "This is the object tourFeaturesExcluded."
    tourFeaturesExcluded: String
    "This is the object tourFeaturesIncluded."
    tourFeaturesIncluded: String
    "This is the object tourIsActive."
    tourIsActive: Boolean
    "This is the object tourName."
    tourName: String
    "This is the object tourPrice."
    tourPrice: String
    "This is the object tourShortDescription."
    tourShortDescription: String
}

"The UpdateTourImageFieldsInput input type is used in operations that involve creation of objects in the TourImage class."
input UpdateTourImageFieldsInput {
    ACL: ACLInput
    "This is the object tourId."
    tourId: TourRelationInput
    "This is the object tourImg."
    tourImg: FileInput
    "This is the object tourThumb."
    tourThumb: FileInput
}

input UpdateTourImageInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateTourImageFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

input UpdateTourInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateTourFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateTourPlaceFieldsInput input type is used in operations that involve creation of objects in the TourPlace class."
input UpdateTourPlaceFieldsInput {
    ACL: ACLInput
    "This is the object placeId."
    placeId: PlaceRelationInput
    "This is the object tourId."
    tourId: TourRelationInput
}

input UpdateTourPlaceInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateTourPlaceFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateTourPromotionFieldsInput input type is used in operations that involve creation of objects in the TourPromotion class."
input UpdateTourPromotionFieldsInput {
    ACL: ACLInput
    "This is the object promoId."
    promoId: PromotionRelationInput
    "This is the object tourId."
    tourId: TourRelationInput
}

input UpdateTourPromotionInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateTourPromotionFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateToursInPackFieldsInput input type is used in operations that involve creation of objects in the ToursInPack class."
input UpdateToursInPackFieldsInput {
    ACL: ACLInput
    "This is the object packId."
    packId: PackRelationInput
    "This is the object tourId."
    tourId: TourRelationInput
}

input UpdateToursInPackInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateToursInPackFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"The UpdateUserFieldsInput input type is used in operations that involve creation of objects in the User class."
input UpdateUserFieldsInput {
    ACL: ACLInput
    "This is the object authData."
    authData: Object
    "This is the object email."
    email: String
    "This is the object emailVerified."
    emailVerified: Boolean
    "This is the object password."
    password: String
    "This is the object username."
    username: String
}

input UpdateUserInput {
    clientMutationId: String
    "These are the fields that will be used to update the object."
    fields: UpdateUserFieldsInput
    "This is the object id. You can use either the global or the object id."
    id: ID!
}

"Allow to manage users in ACL."
input UserACLInput {
    "Allow the user to read the current object."
    read: Boolean!
    "ID of the targetted User."
    userId: ID!
    "Allow the user to write on the current object."
    write: Boolean!
}

input UserLoginWithInput {
    ACL: ACLInput
    "This is the object email."
    email: String
    "This is the object emailVerified."
    emailVerified: Boolean
}

"Allow to link OR add and link an object of the User class."
input UserPointerInput {
    "Create and link an object from User class."
    createAndLink: CreateUserFieldsInput
    "Link an existing object from User class. You can use either the global or the object id."
    link: ID
}

"Allow to add, remove, createAndAdd objects of the User class into a relation field."
input UserRelationInput {
    "Add existing objects from the User class into the relation. You can use either the global or the object ids."
    add: [ID!]
    "Create and add objects of the User class into the relation."
    createAndAdd: [CreateUserFieldsInput!]
    "Remove existing objects from the User class out of the relation. You can use either the global or the object ids."
    remove: [ID!]
}

"The UserRelationWhereInput input type is used in operations that involve filtering objects of User class."
input UserRelationWhereInput {
    "Check if the relation/pointer contains objects."
    exists: Boolean
    "Run a relational/pointer query where at least one child object can match."
    have: UserWhereInput
    "Run an inverted relational/pointer query where at least one child object can match."
    haveNot: UserWhereInput
}

"The UserWhereInput input type is used in operations that involve filtering objects of User class."
input UserWhereInput {
    "This is the object ACL."
    ACL: ObjectWhereInput
    "This is the AND operator to compound constraints."
    AND: [UserWhereInput!]
    "This is the NOR operator to compound constraints."
    NOR: [UserWhereInput!]
    "This is the OR operator to compound constraints."
    OR: [UserWhereInput!]
    "This is the object authData."
    authData: ObjectWhereInput
    "This is the object createdAt."
    createdAt: DateWhereInput
    "This is the object email."
    email: StringWhereInput
    "This is the object emailVerified."
    emailVerified: BooleanWhereInput
    "This is the object id."
    id: IdWhereInput
    "This is the object objectId."
    objectId: IdWhereInput
    "This is the object password."
    password: StringWhereInput
    "This is the object updatedAt."
    updatedAt: DateWhereInput
    "This is the object username."
    username: StringWhereInput
}

"The WithinInput type is used to specify a within operation on a constraint."
input WithinInput {
    "This is the box to be specified."
    box: BoxInput!
}
